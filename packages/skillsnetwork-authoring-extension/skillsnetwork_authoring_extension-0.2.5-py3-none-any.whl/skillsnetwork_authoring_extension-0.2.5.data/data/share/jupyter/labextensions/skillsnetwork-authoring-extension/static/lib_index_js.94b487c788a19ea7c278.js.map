{"version":3,"file":"lib_index_js.94b487c788a19ea7c278.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAA0D;AACL;AACG;AACP;AACW;AACJ;AACpB;AACI;AACgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB,EAAE,oEAAgB,EAAE,2DAAS;AAC5D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAe;AAC9C;AACA;AACA,YAAY,sDAAY,CAAC,sDAAY,CAAC,kDAAa;AACnD;AACA,2BAA2B,+DAAa;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,kEAAkB;AACrC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oDAAW;AAC7B;AACA;AACA;AACA;AACA,yBAAyB,uDAAkB;AAC3C,gBAAgB,2DAAsB,EAAE,0DAAqB;AAC7D;AACA,QAAQ,uDAAkB;AAC1B;AACA;AACA;AACA,sBAAsB,MAAM,2DAAsB;AAClD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAe,SAAS,sDAAY,SAAS,uDAAkB;AACjF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gFAAgF,YAAY,2DAAsB,kBAAkB;AACpI;AACA,kBAAkB,uDAAe,UAAU,sDAAY,SAAS,uDAAkB;AAClF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;;AC/Ff;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC,uCAAuC,YAAY,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;;;;;;;;ACpDA;AACyC;AAC0B;AACnE;AACA;AACA;AACO,4BAA4B,mDAAM;AACzC;AACA;AACA,4BAA4B,yDAAO;AACnC;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,gEAAU;AACd;AACA;AACA,kBAAkB,qEAAmB;AACrC,KAAK;AACL,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACO;AACP,IAAI,gEAAU;AACd;AACA;AACA,kBAAkB,iEAAe;AACjC,KAAK;AACL,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACO;AACP,IAAI,gEAAU;AACd;AACA;AACA,kBAAkB,iEAAe;AACjC,KAAK;AACL,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACO;AACP,IAAI,gEAAU;AACd;AACA;AACA,kBAAkB,iEAAe;AACjC,KAAK;AACL,2BAA2B;AAC3B,2BAA2B;AAC3B;;;;;;;;;;;;;;;;;;;;;;;;AC/DwH;AAC1E;AACS;AAC7B;AACS;AAC5B;AACP;AACA,QAAQ,kDAAa;AACrB;AACA,oEAAoE,oDAAW;AAC/E,wBAAwB,mDAAY;AACpC,iBAAiB,uDAAc;AAC/B;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,8DAAY,IAAI;AACxB;AACA;AACA,KAAK;AACL;AACA,QAAQ,8DAAY,IAAI;AACxB,QAAQ,mEAA0B;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,qDAAY;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,8DAAY,IAAI;AAC5B,YAAY,iEAAwB;AACpC;AACA,SAAS;AACT;AACA;AACA,YAAY,8DAAY,IAAI;AAC5B,YAAY,iEAAwB;AACpC;AACA,SAAS;AACT,KAAK;AACL;;;;;;;;;;;;;;;;;;ACpE8B;AACA;AAC9B;AACA,IAAI,+CAAM;AACV,IAAI,uCAAI;AACR;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACN6B;AACF;AACW;AACF;AACf;AACE;AACD;AACN;AAC7B;AACP;AACA;AACA,eAAe,2DAAS,EAAE,kEAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB,WAAW;AAC3B;AACA,yBAAyB,iDAAI,GAAG,UAAU;AAC1C;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAU;AACtB;AACA,0BAA0B,mDAAM,GAAG,kBAAkB;AACrD,0BAA0B,qEAAmB,IAAI,iEAAe;AAChE,aAAa;AACb;AACA,oBAAoB,qDAAY;AAChC;AACA,wFAAwF,YAAY,2DAAsB,kBAAkB;AAC5I;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAe,UAAU,sDAAY;AAC/D;AACA,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5DqD;AACb;AACxC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,+DAAa;AACnC;AACA;AACA;AACA,qCAAqC,qDAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;ACvGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B","sources":["webpack://skillsnetwork-authoring-extension/./lib/button/index.js","webpack://skillsnetwork-authoring-extension/./lib/config.js","webpack://skillsnetwork-authoring-extension/./lib/dialog.js","webpack://skillsnetwork-authoring-extension/./lib/handler.js","webpack://skillsnetwork-authoring-extension/./lib/index.js","webpack://skillsnetwork-authoring-extension/./lib/menu/index.js","webpack://skillsnetwork-authoring-extension/./lib/tools.js","webpack://skillsnetwork-authoring-extension/./node_modules/process/browser.js"],"sourcesContent":["import { IDocumentManager } from '@jupyterlab/docmanager';\nimport { ToolbarButton } from '@jupyterlab/apputils';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { getFileContents, loadLabContents } from '../tools';\nimport { axiosHandler, postLabModel } from '../handler';\nimport { Globals } from '../config';\nimport { ATLAS_TOKEN } from '../config';\nimport { INotebookTracker } from '@jupyterlab/notebook';\n/**\n * The plugin registration information.\n */\nconst plugin = {\n    activate,\n    id: 'skillsnetwork-authoring-extension:plugin',\n    autoStart: true,\n    requires: [INotebookTracker, IDocumentManager, IMainMenu]\n};\n/**\n * A notebook widget extension that adds a button to the toolbar.\n */\nexport class ButtonExtension {\n    /**\n     * Create a new extension for the notebook panel widget.\n     *\n     * @param panel Notebook panel\n     * @param context Notebook context\n     * @returns Disposable on the added button\n     */\n    createNew(panel, context) {\n        const start = async () => {\n            // Get the current file contents\n            const file = await getFileContents(panel, context);\n            console.log(file);\n            // POST to Atlas the file contents/lab model\n            postLabModel(axiosHandler(Globals.TOKEN), file);\n        };\n        const button = new ToolbarButton({\n            className: 'publish-lab-button',\n            label: 'Publish',\n            onClick: start,\n            tooltip: 'Publish Lab'\n        });\n        panel.toolbar.insertItem(10, 'publish', button);\n        return new DisposableDelegate(() => {\n            button.dispose();\n        });\n    }\n}\n/**\n * Activate the extension.\n *\n * @param app Main application object\n */\nasync function activate(app, mainMenu) {\n    console.log(\"Activated skillsnetwork-authoring-extension button plugin!\");\n    // init the token, globals\n    const token = ATLAS_TOKEN();\n    // Add the Publish widget to the lab environment\n    app.docRegistry.addWidgetExtension('Notebook', new ButtonExtension());\n    // TO DO: Change logic so that we check if the file exists first before trying to open it...\n    // TO DO: Add logic to rename the default file opened to lab's name\n    console.log('where', Globals.AUTHOR_ENV);\n    console.log(Globals.PY_KERNEL_NAME, Globals.LAB_TOOL_TYPE);\n    // Only try to load up a notebook when author is using the browser tool (not in local)\n    if (Globals.AUTHOR_ENV === 'browser') {\n        // Attempt to open the lab\n        await app.commands.execute('docmanager:open', {\n            path: 'Untitled.ipynb',\n            kernel: { name: Globals.PY_KERNEL_NAME }\n        })\n            // The lab was created in a previous session, open up the existing lab\n            .then(async (widget) => {\n            console.log('Successfully got existing file');\n            // Only try to load up lab when author is not in local authoring env\n            // TODO: Refactor this and make it better :')\n            // Load the contents of the lab into the notebook\n            await loadLabContents(widget, axiosHandler(token), Globals.AUTHOR_ENV)\n                .then(() => widget.show())\n                .catch();\n        })\n            // This is the user's first session, create the lab first and open it for them\n            .catch(async () => {\n            console.log('Could not open file. Creating new file.');\n            // Create a new notebook with Panel\n            const nbPanel = await app.commands.execute('notebook:create-new', { kernelName: Globals.PY_KERNEL_NAME, activate: true });\n            console.log('Created a new file!');\n            await loadLabContents(nbPanel, axiosHandler(token), Globals.AUTHOR_ENV)\n                .then(() => nbPanel.show());\n        });\n    }\n}\n/**\n * Export the plugin as default.\n */\nexport default plugin;\n","export const ATLAS_BASE_URL = () => {\n    var _a;\n    const currentURL = window.location.href;\n    const params = new URL(currentURL).searchParams;\n    const base_url = params.get('atlas_base_url');\n    if (base_url === null) {\n        return (_a = process.env.ATLAS_BASE_URL) !== null && _a !== void 0 ? _a : 'https://author.skills.network/atlas';\n        // 'https://author.staging.skills.network/atlas'\n    }\n    return base_url;\n};\n/**\n * Extracts the session token. Will first try to get a token via the URL, if none was found then try to get the token via cookie.\n *\n * @returns token\n */\nexport const ATLAS_TOKEN = () => {\n    var _a;\n    const currentURL = window.location.href;\n    //console.log('currentURL', currentURL);\n    const params = new URL(currentURL).searchParams;\n    let token = params.get('token');\n    //console.log('token from url:', token)\n    Globals.LAB_TOOL_TYPE = 'JUPYTER_LITE';\n    if (token === null) {\n        // Try getting it from cookie\n        const COOKIE_NAME = (_a = process.env.ATLAS_TOKEN_COOKIE_NAME) !== null && _a !== void 0 ? _a : 'atlas_token';\n        const reg = new RegExp(`(^| )${COOKIE_NAME}=([^;]+)`);\n        let match = reg.exec(document.cookie);\n        // If found then set that as our token o/w set it as empty str for now\n        (match !== null) ? token = match[2] : token = 'NO_TOKEN';\n        //console.log('token from cookie:', token)\n        Globals.LAB_TOOL_TYPE = 'JUPYTER_LAB';\n    }\n    if (token === null || token === 'NO_TOKEN') {\n        // If no token was found in the URL or cookies, the author is in their local env (hopefully...)\n        Globals.AUTHOR_ENV = 'local';\n    }\n    else {\n        Globals.AUTHOR_ENV = 'browser';\n    }\n    if (Globals.LAB_TOOL_TYPE === 'JUPYTER_LAB') {\n        Globals.PY_KERNEL_NAME = 'python3';\n    }\n    else if (Globals.LAB_TOOL_TYPE === 'JUPYTER_LITE') {\n        Globals.PY_KERNEL_NAME = 'python';\n    }\n    Globals.TOKEN = token;\n    return token;\n};\n// Global token variable that will store the\nexport class Globals {\n}\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { Widget } from '@lumino/widgets';\nimport { Dialog, showDialog, Spinner } from '@jupyterlab/apputils';\n/**\n * A widget that holds the loading spinner\n */\nexport class SpinnerDialog extends Widget {\n    constructor() {\n        const body = document.createElement('div');\n        const spinner = new Spinner();\n        body.appendChild(spinner.node);\n        body.style.padding = '15px';\n        super({ node: body });\n    }\n}\n/**\n * Shows the Loading dialog\n */\nexport const show_spinner = (message) => {\n    const spinWidget = new SpinnerDialog();\n    showDialog({\n        title: message,\n        body: spinWidget,\n        buttons: [Dialog.cancelButton()]\n    })\n        .then(result => { })\n        .catch(error => { });\n};\n/**\n * Shows the Success dialog\n */\nexport const showSuccessPublishDialog = () => {\n    showDialog({\n        title: 'Success!',\n        body: 'This lab was successfully submitted for publishing!',\n        buttons: [Dialog.okButton()]\n    })\n        .then(result => { })\n        .catch(error => { });\n};\n/**\n * Shows the Failed to publish dialog\n */\nexport const showFailurePublishDialog = () => {\n    showDialog({\n        title: 'Failed to Publish',\n        body: 'This lab failed to publish.',\n        buttons: [Dialog.okButton()]\n    })\n        .then(result => { })\n        .catch(error => { });\n};\n/**\n * Shows the Failed to load lab dialog\n */\nexport const showFailureImportLabDialog = () => {\n    showDialog({\n        title: 'Failed to Load Lab',\n        body: 'This lab failed to load.',\n        buttons: [Dialog.okButton()]\n    })\n        .then(result => { })\n        .catch(error => { });\n};\n","import { show_spinner, showSuccessPublishDialog, showFailurePublishDialog, showFailureImportLabDialog } from './dialog';\nimport { Dialog } from '@jupyterlab/apputils';\nimport { ATLAS_BASE_URL, ATLAS_TOKEN } from './config';\nimport axios from 'axios';\nimport { Globals } from './config';\nexport const axiosHandler = (lab_token) => {\n    if (lab_token)\n        Globals.TOKEN = lab_token;\n    let auth_token;\n    lab_token !== undefined ? auth_token = lab_token : auth_token = ATLAS_TOKEN();\n    const atlasClient = axios.create({\n        baseURL: ATLAS_BASE_URL(),\n        headers: {\n            Authorization: `Bearer ${auth_token}`,\n            'Content-Type': 'application/json',\n            'Access-Control-Allow-Origin': '*'\n        }\n    });\n    return atlasClient;\n};\n/**\n * GET the lab model / JSON that represents a .ipynb file/notebook from ATLAS\n *\n * @param axiosHandler Axios client that contains a JWT Bearer token\n * @returns Promise<void>\n */\nexport const getLabModel = (axiosHandler) => {\n    // GET the lab model\n    return axiosHandler\n        .get('v1/labs')\n        .then(result => {\n        Dialog.flush(); //remove spinner\n        console.log(result.data);\n        return JSON.parse(result.data.body);\n    })\n        .catch(error => {\n        Dialog.flush(); //remove spinner\n        showFailureImportLabDialog();\n        console.log(error);\n        return 0;\n    });\n};\n/**\n * POST the lab model / JSON from the .ipynb file/notebook to ATLAS\n *\n * @param axiosHandler Axios client that contains a JWT Bearer token\n * @returns Promise<void>\n */\nexport const postLabModel = async (axiosHandler, labModel) => {\n    show_spinner('Publishing...');\n    return new Promise(async (resolve, reject) => {\n        await axiosHandler\n            .post('v1/labs', {\n            body: labModel\n        })\n            .then(res => {\n            console.log('SUCCESSFULLY PUSHED', res);\n            Dialog.flush(); //remove spinner\n            showSuccessPublishDialog();\n            resolve;\n        })\n            .catch((error) => {\n            console.log(error);\n            Dialog.flush(); // remove spinner\n            showFailurePublishDialog();\n            reject;\n        });\n    });\n};\n","import { menu } from './menu';\nimport plugin from './button';\nconst main = [\n    plugin,\n    menu\n];\nexport default main;\n","import { IMainMenu } from '@jupyterlab/mainmenu';\nimport { Menu, Widget } from '@lumino/widgets';\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { show_spinner } from '../dialog';\nimport { loadLabContents } from '../tools';\nimport { axiosHandler } from '../handler';\nimport { Globals } from '../config';\nexport const menu = {\n    id: 'skillsnetwork-authoring-extension:menu',\n    autoStart: true,\n    requires: [IMainMenu, INotebookTracker],\n    activate: (app, mainMenu, notebookTracker) => {\n        console.log('Activated skillsnetwork-authoring-extension menu plugin!');\n        const editLabFromToken = 'edit-lab-from-token';\n        app.commands.addCommand(editLabFromToken, {\n            label: 'Edit a Lab',\n            execute: () => {\n                showTokenDialog(notebookTracker);\n            }\n        });\n        const { commands } = app;\n        // Create a new menu\n        const menu = new Menu({ commands });\n        menu.title.label = 'Skills Network';\n        mainMenu.addMenu(menu, { rank: 80 });\n        // Add command to menu\n        menu.addItem({\n            command: editLabFromToken,\n            args: {}\n        });\n        const showTokenDialog = (notebookTracker) => {\n            // Generate Dialog body\n            let bodyDialog = document.createElement('div');\n            let nameLabel = document.createElement('label');\n            nameLabel.textContent = \"Enter your authorization token: \";\n            let tokenInput = document.createElement('input');\n            tokenInput.className = \"jp-mod-styled\";\n            bodyDialog.appendChild(nameLabel);\n            bodyDialog.appendChild(tokenInput);\n            showDialog({\n                title: \"Edit a Lab\",\n                body: new Widget({ node: bodyDialog }),\n                buttons: [Dialog.cancelButton(), Dialog.okButton()]\n            }).then(async (result) => {\n                if (result.button.accept) {\n                    show_spinner('Loading up your lab...');\n                    // Open up a blank notebook, set the kernel and load up lab\n                    const nbPanel = await app.commands.execute('notebook:create-new', { kernelName: Globals.PY_KERNEL_NAME, activate: true });\n                    console.log('Created a new file!');\n                    if (nbPanel === null) {\n                        throw Error('Error loading lab');\n                    }\n                    nbPanel.show();\n                    await loadLabContents(nbPanel, axiosHandler(tokenInput.value));\n                }\n            })\n                .catch();\n        };\n    }\n};\n","import { NotebookModel } from '@jupyterlab/notebook';\nimport { getLabModel } from './handler';\n/**\n * Extracts the relevant data from the cells of the notebook\n *\n * @param cell Cell model\n * @returns ICellData object\n */\nexport const getCellContents = (cell) => {\n    const cellData = {\n        cell_type: cell.model.type,\n        id: cell.model.id,\n        metadata: {},\n        outputs: [],\n        source: [cell.model.value.text]\n    };\n    return cellData;\n};\n/**\n * Gets the raw data (cell models and content, notebook configurations) from the .ipynb file\n *\n * @param panel Notebook panel\n * @param context Notebook context\n */\nexport const getFileContents = (panel, context) => {\n    // Cell types: \"code\" | \"markdown\" | \"raw\"\n    const allCells = [];\n    panel.content.widgets.forEach((cell) => {\n        const cellData = getCellContents(cell);\n        allCells.push(cellData);\n    });\n    // Get the configs from the notebook model\n    const config_meta = context.model.metadata.toJSON();\n    const config_nbmajor = context.model.nbformat;\n    const config_nbminor = context.model.nbformatMinor;\n    // Put all data into IPynbRaw object\n    const rawFile = {\n        cells: allCells,\n        metadata: config_meta,\n        nbformat: config_nbmajor,\n        nbformat_minor: config_nbminor\n    };\n    return JSON.stringify(rawFile, null, 2);\n};\nexport const loadLabContents = async (widget, axiosHandlers, author_env) => {\n    const model = new NotebookModel();\n    // Only try to load the initial lab notebook if the author is not coming from their local env\n    if (author_env !== 'local') {\n        try {\n            const lab_model = (await getLabModel(axiosHandlers));\n            // console.log('heres the model: ', lab_model);\n            model.fromJSON(lab_model);\n        }\n        catch (_a) {\n            throw 'Error getting lab model';\n        }\n        // testing purposes\n        //model.fromJSON(DEFAULT_CONTENT);\n    }\n    // testing purposes:\n    // model.fromJSON(DEFAULT_CONTENT);\n    widget.content.model = model;\n};\n// eslint-disable-next-line @typescript-eslint/quotes\nexport const DEFAULT_CONTENT = {\n    cells: [\n        {\n            cell_type: 'code',\n            id: 'c852569f-bf26-4994-88e7-3b94874d3853',\n            metadata: {},\n            source: ['print(\"hello world again\")']\n        },\n        {\n            cell_type: 'markdown',\n            id: '5a2dc856-763a-4f12-b675-481ed971178a',\n            metadata: {},\n            source: ['this is markdown']\n        },\n        {\n            cell_type: 'raw',\n            id: '492a02e8-ec75-49f7-8560-b30256bca6af',\n            metadata: {},\n            source: ['this is raw']\n        }\n    ],\n    metadata: {\n        kernelspec: {\n            display_name: 'Python 3 (ipykernel)',\n            language: 'python',\n            name: 'python3'\n        },\n        language_info: {\n            codemirror_mode: { name: 'ipython', version: 3 },\n            file_extension: '.py',\n            mimetype: 'text/x-python',\n            name: 'python',\n            nbconvert_exporter: 'python',\n            pygments_lexer: 'ipython3',\n            version: '3.10.4'\n        }\n    },\n    nbformat: 4,\n    nbformat_minor: 5\n};\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"names":[],"sourceRoot":""}