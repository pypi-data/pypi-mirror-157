# coding: utf-8

"""
    Sangfor AD API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 7.0.5
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from adapi_sdk.api_client import ApiClient


class PreRuleApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_pre_rule_dns_list(self, pre_rule_dns_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（DNS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_dns_list(pre_rule_dns_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleDns pre_rule_dns_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pre_rule_dns_list_with_http_info(pre_rule_dns_config, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pre_rule_dns_list_with_http_info(pre_rule_dns_config, **kwargs)  # noqa: E501
            return data

    def add_pre_rule_dns_list_with_http_info(self, pre_rule_dns_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（DNS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_dns_list_with_http_info(pre_rule_dns_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleDns pre_rule_dns_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pre_rule_dns_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pre_rule_dns_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pre_rule_dns_config' is set
        if ('pre_rule_dns_config' not in params or
                params['pre_rule_dns_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_dns_config` when calling `add_pre_rule_dns_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_dns_config' in params:
            body_params = params['pre_rule_dns_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/dns/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleDns',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pre_rule_ftp_list(self, pre_rule_ftp_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（FTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_ftp_list(pre_rule_ftp_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleFtp pre_rule_ftp_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pre_rule_ftp_list_with_http_info(pre_rule_ftp_config, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pre_rule_ftp_list_with_http_info(pre_rule_ftp_config, **kwargs)  # noqa: E501
            return data

    def add_pre_rule_ftp_list_with_http_info(self, pre_rule_ftp_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（FTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_ftp_list_with_http_info(pre_rule_ftp_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleFtp pre_rule_ftp_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pre_rule_ftp_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pre_rule_ftp_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pre_rule_ftp_config' is set
        if ('pre_rule_ftp_config' not in params or
                params['pre_rule_ftp_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ftp_config` when calling `add_pre_rule_ftp_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ftp_config' in params:
            body_params = params['pre_rule_ftp_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ftp/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleFtp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pre_rule_http_list(self, pre_rule_http_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（HTTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_http_list(pre_rule_http_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleHttp pre_rule_http_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pre_rule_http_list_with_http_info(pre_rule_http_config, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pre_rule_http_list_with_http_info(pre_rule_http_config, **kwargs)  # noqa: E501
            return data

    def add_pre_rule_http_list_with_http_info(self, pre_rule_http_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（HTTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_http_list_with_http_info(pre_rule_http_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleHttp pre_rule_http_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pre_rule_http_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pre_rule_http_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pre_rule_http_config' is set
        if ('pre_rule_http_config' not in params or
                params['pre_rule_http_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_http_config` when calling `add_pre_rule_http_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_http_config' in params:
            body_params = params['pre_rule_http_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/http/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleHttp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pre_rule_ip_list(self, pre_rule_ip_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个IP三层前置策略（L3）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_ip_list(pre_rule_ip_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleIp pre_rule_ip_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pre_rule_ip_list_with_http_info(pre_rule_ip_config, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pre_rule_ip_list_with_http_info(pre_rule_ip_config, **kwargs)  # noqa: E501
            return data

    def add_pre_rule_ip_list_with_http_info(self, pre_rule_ip_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个IP三层前置策略（L3）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_ip_list_with_http_info(pre_rule_ip_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleIp pre_rule_ip_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pre_rule_ip_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pre_rule_ip_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pre_rule_ip_config' is set
        if ('pre_rule_ip_config' not in params or
                params['pre_rule_ip_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ip_config` when calling `add_pre_rule_ip_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ip_config' in params:
            body_params = params['pre_rule_ip_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ip/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleIp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pre_rule_radius_list(self, pre_rule_radius_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（RADIUS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_radius_list(pre_rule_radius_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleRadius pre_rule_radius_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pre_rule_radius_list_with_http_info(pre_rule_radius_config, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pre_rule_radius_list_with_http_info(pre_rule_radius_config, **kwargs)  # noqa: E501
            return data

    def add_pre_rule_radius_list_with_http_info(self, pre_rule_radius_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（RADIUS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_radius_list_with_http_info(pre_rule_radius_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleRadius pre_rule_radius_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pre_rule_radius_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pre_rule_radius_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pre_rule_radius_config' is set
        if ('pre_rule_radius_config' not in params or
                params['pre_rule_radius_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_radius_config` when calling `add_pre_rule_radius_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_radius_config' in params:
            body_params = params['pre_rule_radius_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/radius/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleRadius',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pre_rule_sip_list(self, pre_rule_sip_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（SIP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_sip_list(pre_rule_sip_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleSip pre_rule_sip_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pre_rule_sip_list_with_http_info(pre_rule_sip_config, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pre_rule_sip_list_with_http_info(pre_rule_sip_config, **kwargs)  # noqa: E501
            return data

    def add_pre_rule_sip_list_with_http_info(self, pre_rule_sip_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（SIP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_sip_list_with_http_info(pre_rule_sip_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleSip pre_rule_sip_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pre_rule_sip_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pre_rule_sip_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pre_rule_sip_config' is set
        if ('pre_rule_sip_config' not in params or
                params['pre_rule_sip_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_sip_config` when calling `add_pre_rule_sip_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_sip_config' in params:
            body_params = params['pre_rule_sip_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/sip/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSip',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pre_rule_ssl_offload_https_list(self, pre_rule_ssl_offload_https_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（HTTPS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_ssl_offload_https_list(pre_rule_ssl_offload_https_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleSslOffloadHttps pre_rule_ssl_offload_https_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pre_rule_ssl_offload_https_list_with_http_info(pre_rule_ssl_offload_https_config, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pre_rule_ssl_offload_https_list_with_http_info(pre_rule_ssl_offload_https_config, **kwargs)  # noqa: E501
            return data

    def add_pre_rule_ssl_offload_https_list_with_http_info(self, pre_rule_ssl_offload_https_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（HTTPS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_ssl_offload_https_list_with_http_info(pre_rule_ssl_offload_https_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleSslOffloadHttps pre_rule_ssl_offload_https_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pre_rule_ssl_offload_https_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pre_rule_ssl_offload_https_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pre_rule_ssl_offload_https_config' is set
        if ('pre_rule_ssl_offload_https_config' not in params or
                params['pre_rule_ssl_offload_https_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ssl_offload_https_config` when calling `add_pre_rule_ssl_offload_https_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ssl_offload_https_config' in params:
            body_params = params['pre_rule_ssl_offload_https_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload-https/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffloadHttps',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pre_rule_ssl_offload_list(self, pre_rule_ssl_offload_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（SSL）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_ssl_offload_list(pre_rule_ssl_offload_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleSslOffload pre_rule_ssl_offload_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pre_rule_ssl_offload_list_with_http_info(pre_rule_ssl_offload_config, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pre_rule_ssl_offload_list_with_http_info(pre_rule_ssl_offload_config, **kwargs)  # noqa: E501
            return data

    def add_pre_rule_ssl_offload_list_with_http_info(self, pre_rule_ssl_offload_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（SSL）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_ssl_offload_list_with_http_info(pre_rule_ssl_offload_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleSslOffload pre_rule_ssl_offload_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pre_rule_ssl_offload_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pre_rule_ssl_offload_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pre_rule_ssl_offload_config' is set
        if ('pre_rule_ssl_offload_config' not in params or
                params['pre_rule_ssl_offload_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ssl_offload_config` when calling `add_pre_rule_ssl_offload_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ssl_offload_config' in params:
            body_params = params['pre_rule_ssl_offload_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pre_rule_tcp_forward_list(self, pre_rule_tcp_forward_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（TCP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_tcp_forward_list(pre_rule_tcp_forward_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleTcpForward pre_rule_tcp_forward_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pre_rule_tcp_forward_list_with_http_info(pre_rule_tcp_forward_config, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pre_rule_tcp_forward_list_with_http_info(pre_rule_tcp_forward_config, **kwargs)  # noqa: E501
            return data

    def add_pre_rule_tcp_forward_list_with_http_info(self, pre_rule_tcp_forward_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（TCP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_tcp_forward_list_with_http_info(pre_rule_tcp_forward_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleTcpForward pre_rule_tcp_forward_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pre_rule_tcp_forward_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pre_rule_tcp_forward_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pre_rule_tcp_forward_config' is set
        if ('pre_rule_tcp_forward_config' not in params or
                params['pre_rule_tcp_forward_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_tcp_forward_config` when calling `add_pre_rule_tcp_forward_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_tcp_forward_config' in params:
            body_params = params['pre_rule_tcp_forward_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-forward/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pre_rule_tcp_proxy_list(self, pre_rule_tcp_proxy_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（TCP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_tcp_proxy_list(pre_rule_tcp_proxy_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleTcpProxy pre_rule_tcp_proxy_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pre_rule_tcp_proxy_list_with_http_info(pre_rule_tcp_proxy_config, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pre_rule_tcp_proxy_list_with_http_info(pre_rule_tcp_proxy_config, **kwargs)  # noqa: E501
            return data

    def add_pre_rule_tcp_proxy_list_with_http_info(self, pre_rule_tcp_proxy_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（TCP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_tcp_proxy_list_with_http_info(pre_rule_tcp_proxy_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleTcpProxy pre_rule_tcp_proxy_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pre_rule_tcp_proxy_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pre_rule_tcp_proxy_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pre_rule_tcp_proxy_config' is set
        if ('pre_rule_tcp_proxy_config' not in params or
                params['pre_rule_tcp_proxy_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_tcp_proxy_config` when calling `add_pre_rule_tcp_proxy_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_tcp_proxy_config' in params:
            body_params = params['pre_rule_tcp_proxy_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-proxy/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pre_rule_udp_forward_list(self, pre_rule_udp_forward_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（UDP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_udp_forward_list(pre_rule_udp_forward_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleUdpForward pre_rule_udp_forward_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pre_rule_udp_forward_list_with_http_info(pre_rule_udp_forward_config, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pre_rule_udp_forward_list_with_http_info(pre_rule_udp_forward_config, **kwargs)  # noqa: E501
            return data

    def add_pre_rule_udp_forward_list_with_http_info(self, pre_rule_udp_forward_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（UDP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_udp_forward_list_with_http_info(pre_rule_udp_forward_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleUdpForward pre_rule_udp_forward_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pre_rule_udp_forward_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pre_rule_udp_forward_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pre_rule_udp_forward_config' is set
        if ('pre_rule_udp_forward_config' not in params or
                params['pre_rule_udp_forward_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_udp_forward_config` when calling `add_pre_rule_udp_forward_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_udp_forward_config' in params:
            body_params = params['pre_rule_udp_forward_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-forward/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pre_rule_udp_proxy_list(self, pre_rule_udp_proxy_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（UDP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_udp_proxy_list(pre_rule_udp_proxy_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleUdpProxy pre_rule_udp_proxy_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_pre_rule_udp_proxy_list_with_http_info(pre_rule_udp_proxy_config, **kwargs)  # noqa: E501
        else:
            (data) = self.add_pre_rule_udp_proxy_list_with_http_info(pre_rule_udp_proxy_config, **kwargs)  # noqa: E501
            return data

    def add_pre_rule_udp_proxy_list_with_http_info(self, pre_rule_udp_proxy_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建一个前置策略（UDP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pre_rule_udp_proxy_list_with_http_info(pre_rule_udp_proxy_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ConfigPreRuleUdpProxy pre_rule_udp_proxy_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pre_rule_udp_proxy_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pre_rule_udp_proxy_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pre_rule_udp_proxy_config' is set
        if ('pre_rule_udp_proxy_config' not in params or
                params['pre_rule_udp_proxy_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_udp_proxy_config` when calling `add_pre_rule_udp_proxy_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_udp_proxy_config' in params:
            body_params = params['pre_rule_udp_proxy_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-proxy/', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_pre_rule_dns(self, name, pre_rule_dns_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（DNS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_dns(name, pre_rule_dns_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleDns pre_rule_dns_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pre_rule_dns_with_http_info(name, pre_rule_dns_config, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pre_rule_dns_with_http_info(name, pre_rule_dns_config, **kwargs)  # noqa: E501
            return data

    def create_pre_rule_dns_with_http_info(self, name, pre_rule_dns_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（DNS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_dns_with_http_info(name, pre_rule_dns_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleDns pre_rule_dns_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_dns_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pre_rule_dns" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_pre_rule_dns`")  # noqa: E501
        # verify the required parameter 'pre_rule_dns_config' is set
        if ('pre_rule_dns_config' not in params or
                params['pre_rule_dns_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_dns_config` when calling `create_pre_rule_dns`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_dns_config' in params:
            body_params = params['pre_rule_dns_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/dns/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleDns',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_pre_rule_ftp(self, name, pre_rule_ftp_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（FTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_ftp(name, pre_rule_ftp_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleFtp pre_rule_ftp_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pre_rule_ftp_with_http_info(name, pre_rule_ftp_config, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pre_rule_ftp_with_http_info(name, pre_rule_ftp_config, **kwargs)  # noqa: E501
            return data

    def create_pre_rule_ftp_with_http_info(self, name, pre_rule_ftp_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（FTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_ftp_with_http_info(name, pre_rule_ftp_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleFtp pre_rule_ftp_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_ftp_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pre_rule_ftp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_pre_rule_ftp`")  # noqa: E501
        # verify the required parameter 'pre_rule_ftp_config' is set
        if ('pre_rule_ftp_config' not in params or
                params['pre_rule_ftp_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ftp_config` when calling `create_pre_rule_ftp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ftp_config' in params:
            body_params = params['pre_rule_ftp_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ftp/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleFtp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_pre_rule_http(self, name, pre_rule_http_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        查看指定的前置策略（HTTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_http(name, pre_rule_http_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleHttp pre_rule_http_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pre_rule_http_with_http_info(name, pre_rule_http_config, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pre_rule_http_with_http_info(name, pre_rule_http_config, **kwargs)  # noqa: E501
            return data

    def create_pre_rule_http_with_http_info(self, name, pre_rule_http_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        查看指定的前置策略（HTTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_http_with_http_info(name, pre_rule_http_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleHttp pre_rule_http_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_http_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pre_rule_http" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_pre_rule_http`")  # noqa: E501
        # verify the required parameter 'pre_rule_http_config' is set
        if ('pre_rule_http_config' not in params or
                params['pre_rule_http_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_http_config` when calling `create_pre_rule_http`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_http_config' in params:
            body_params = params['pre_rule_http_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/http/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleHttp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_pre_rule_ip(self, name, pre_rule_ip_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的IP三层前置策略（L3）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_ip(name, pre_rule_ip_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleIp pre_rule_ip_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pre_rule_ip_with_http_info(name, pre_rule_ip_config, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pre_rule_ip_with_http_info(name, pre_rule_ip_config, **kwargs)  # noqa: E501
            return data

    def create_pre_rule_ip_with_http_info(self, name, pre_rule_ip_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的IP三层前置策略（L3）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_ip_with_http_info(name, pre_rule_ip_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleIp pre_rule_ip_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_ip_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pre_rule_ip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_pre_rule_ip`")  # noqa: E501
        # verify the required parameter 'pre_rule_ip_config' is set
        if ('pre_rule_ip_config' not in params or
                params['pre_rule_ip_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ip_config` when calling `create_pre_rule_ip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ip_config' in params:
            body_params = params['pre_rule_ip_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ip/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleIp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_pre_rule_radius(self, name, pre_rule_radius_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（RADIUS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_radius(name, pre_rule_radius_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleRadius pre_rule_radius_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pre_rule_radius_with_http_info(name, pre_rule_radius_config, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pre_rule_radius_with_http_info(name, pre_rule_radius_config, **kwargs)  # noqa: E501
            return data

    def create_pre_rule_radius_with_http_info(self, name, pre_rule_radius_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（RADIUS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_radius_with_http_info(name, pre_rule_radius_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleRadius pre_rule_radius_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_radius_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pre_rule_radius" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_pre_rule_radius`")  # noqa: E501
        # verify the required parameter 'pre_rule_radius_config' is set
        if ('pre_rule_radius_config' not in params or
                params['pre_rule_radius_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_radius_config` when calling `create_pre_rule_radius`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_radius_config' in params:
            body_params = params['pre_rule_radius_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/radius/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleRadius',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_pre_rule_sip(self, name, pre_rule_sip_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（SIP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_sip(name, pre_rule_sip_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSip pre_rule_sip_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pre_rule_sip_with_http_info(name, pre_rule_sip_config, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pre_rule_sip_with_http_info(name, pre_rule_sip_config, **kwargs)  # noqa: E501
            return data

    def create_pre_rule_sip_with_http_info(self, name, pre_rule_sip_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（SIP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_sip_with_http_info(name, pre_rule_sip_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSip pre_rule_sip_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_sip_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pre_rule_sip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_pre_rule_sip`")  # noqa: E501
        # verify the required parameter 'pre_rule_sip_config' is set
        if ('pre_rule_sip_config' not in params or
                params['pre_rule_sip_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_sip_config` when calling `create_pre_rule_sip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_sip_config' in params:
            body_params = params['pre_rule_sip_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/sip/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSip',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_pre_rule_ssl_offload(self, name, pre_rule_ssl_offload_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（SSL）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_ssl_offload(name, pre_rule_ssl_offload_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSslOffload pre_rule_ssl_offload_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pre_rule_ssl_offload_with_http_info(name, pre_rule_ssl_offload_config, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pre_rule_ssl_offload_with_http_info(name, pre_rule_ssl_offload_config, **kwargs)  # noqa: E501
            return data

    def create_pre_rule_ssl_offload_with_http_info(self, name, pre_rule_ssl_offload_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（SSL）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_ssl_offload_with_http_info(name, pre_rule_ssl_offload_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSslOffload pre_rule_ssl_offload_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_ssl_offload_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pre_rule_ssl_offload" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_pre_rule_ssl_offload`")  # noqa: E501
        # verify the required parameter 'pre_rule_ssl_offload_config' is set
        if ('pre_rule_ssl_offload_config' not in params or
                params['pre_rule_ssl_offload_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ssl_offload_config` when calling `create_pre_rule_ssl_offload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ssl_offload_config' in params:
            body_params = params['pre_rule_ssl_offload_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_pre_rule_ssl_offload_https(self, name, pre_rule_ssl_offload_https_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（HTTPS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_ssl_offload_https(name, pre_rule_ssl_offload_https_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSslOffloadHttps pre_rule_ssl_offload_https_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pre_rule_ssl_offload_https_with_http_info(name, pre_rule_ssl_offload_https_config, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pre_rule_ssl_offload_https_with_http_info(name, pre_rule_ssl_offload_https_config, **kwargs)  # noqa: E501
            return data

    def create_pre_rule_ssl_offload_https_with_http_info(self, name, pre_rule_ssl_offload_https_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（HTTPS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_ssl_offload_https_with_http_info(name, pre_rule_ssl_offload_https_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSslOffloadHttps pre_rule_ssl_offload_https_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_ssl_offload_https_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pre_rule_ssl_offload_https" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_pre_rule_ssl_offload_https`")  # noqa: E501
        # verify the required parameter 'pre_rule_ssl_offload_https_config' is set
        if ('pre_rule_ssl_offload_https_config' not in params or
                params['pre_rule_ssl_offload_https_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ssl_offload_https_config` when calling `create_pre_rule_ssl_offload_https`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ssl_offload_https_config' in params:
            body_params = params['pre_rule_ssl_offload_https_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload-https/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffloadHttps',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_pre_rule_tcp_forward(self, name, pre_rule_tcp_forward_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（TCP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_tcp_forward(name, pre_rule_tcp_forward_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleTcpForward pre_rule_tcp_forward_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pre_rule_tcp_forward_with_http_info(name, pre_rule_tcp_forward_config, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pre_rule_tcp_forward_with_http_info(name, pre_rule_tcp_forward_config, **kwargs)  # noqa: E501
            return data

    def create_pre_rule_tcp_forward_with_http_info(self, name, pre_rule_tcp_forward_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（TCP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_tcp_forward_with_http_info(name, pre_rule_tcp_forward_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleTcpForward pre_rule_tcp_forward_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_tcp_forward_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pre_rule_tcp_forward" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_pre_rule_tcp_forward`")  # noqa: E501
        # verify the required parameter 'pre_rule_tcp_forward_config' is set
        if ('pre_rule_tcp_forward_config' not in params or
                params['pre_rule_tcp_forward_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_tcp_forward_config` when calling `create_pre_rule_tcp_forward`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_tcp_forward_config' in params:
            body_params = params['pre_rule_tcp_forward_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-forward/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_pre_rule_tcp_proxy(self, name, pre_rule_tcp_proxy_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（TCP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_tcp_proxy(name, pre_rule_tcp_proxy_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleTcpProxy pre_rule_tcp_proxy_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pre_rule_tcp_proxy_with_http_info(name, pre_rule_tcp_proxy_config, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pre_rule_tcp_proxy_with_http_info(name, pre_rule_tcp_proxy_config, **kwargs)  # noqa: E501
            return data

    def create_pre_rule_tcp_proxy_with_http_info(self, name, pre_rule_tcp_proxy_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（TCP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_tcp_proxy_with_http_info(name, pre_rule_tcp_proxy_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleTcpProxy pre_rule_tcp_proxy_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_tcp_proxy_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pre_rule_tcp_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_pre_rule_tcp_proxy`")  # noqa: E501
        # verify the required parameter 'pre_rule_tcp_proxy_config' is set
        if ('pre_rule_tcp_proxy_config' not in params or
                params['pre_rule_tcp_proxy_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_tcp_proxy_config` when calling `create_pre_rule_tcp_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_tcp_proxy_config' in params:
            body_params = params['pre_rule_tcp_proxy_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-proxy/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_pre_rule_udp_forward(self, name, pre_rule_udp_forward_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（UDP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_udp_forward(name, pre_rule_udp_forward_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleUdpForward pre_rule_udp_forward_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pre_rule_udp_forward_with_http_info(name, pre_rule_udp_forward_config, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pre_rule_udp_forward_with_http_info(name, pre_rule_udp_forward_config, **kwargs)  # noqa: E501
            return data

    def create_pre_rule_udp_forward_with_http_info(self, name, pre_rule_udp_forward_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（UDP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_udp_forward_with_http_info(name, pre_rule_udp_forward_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleUdpForward pre_rule_udp_forward_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_udp_forward_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pre_rule_udp_forward" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_pre_rule_udp_forward`")  # noqa: E501
        # verify the required parameter 'pre_rule_udp_forward_config' is set
        if ('pre_rule_udp_forward_config' not in params or
                params['pre_rule_udp_forward_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_udp_forward_config` when calling `create_pre_rule_udp_forward`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_udp_forward_config' in params:
            body_params = params['pre_rule_udp_forward_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-forward/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_pre_rule_udp_proxy(self, name, pre_rule_udp_proxy_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（UDP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_udp_proxy(name, pre_rule_udp_proxy_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleUdpProxy pre_rule_udp_proxy_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_pre_rule_udp_proxy_with_http_info(name, pre_rule_udp_proxy_config, **kwargs)  # noqa: E501
        else:
            (data) = self.create_pre_rule_udp_proxy_with_http_info(name, pre_rule_udp_proxy_config, **kwargs)  # noqa: E501
            return data

    def create_pre_rule_udp_proxy_with_http_info(self, name, pre_rule_udp_proxy_config, **kwargs):  # noqa: E501
        """create new pre-rule  # noqa: E501

        新建指定的前置策略（UDP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_pre_rule_udp_proxy_with_http_info(name, pre_rule_udp_proxy_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleUdpProxy pre_rule_udp_proxy_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_udp_proxy_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_pre_rule_udp_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_pre_rule_udp_proxy`")  # noqa: E501
        # verify the required parameter 'pre_rule_udp_proxy_config' is set
        if ('pre_rule_udp_proxy_config' not in params or
                params['pre_rule_udp_proxy_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_udp_proxy_config` when calling `create_pre_rule_udp_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_udp_proxy_config' in params:
            body_params = params['pre_rule_udp_proxy_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-proxy/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pre_rule_dns(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（DNS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_dns(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pre_rule_dns_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pre_rule_dns_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_pre_rule_dns_with_http_info(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（DNS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_dns_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pre_rule_dns" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_pre_rule_dns`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/dns/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleDns',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pre_rule_ftp(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（FTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_ftp(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pre_rule_ftp_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pre_rule_ftp_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_pre_rule_ftp_with_http_info(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（FTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_ftp_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pre_rule_ftp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_pre_rule_ftp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ftp/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleFtp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pre_rule_http(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（HTTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_http(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pre_rule_http_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pre_rule_http_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_pre_rule_http_with_http_info(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（HTTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_http_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pre_rule_http" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_pre_rule_http`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/http/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleHttp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pre_rule_ip(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的IP三层前置策略（L3）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_ip(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pre_rule_ip_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pre_rule_ip_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_pre_rule_ip_with_http_info(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的IP三层前置策略（L3）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_ip_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pre_rule_ip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_pre_rule_ip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ip/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleIp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pre_rule_radius(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（RADIUS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_radius(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pre_rule_radius_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pre_rule_radius_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_pre_rule_radius_with_http_info(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（RADIUS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_radius_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pre_rule_radius" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_pre_rule_radius`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/radius/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleRadius',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pre_rule_sip(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（SIP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_sip(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pre_rule_sip_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pre_rule_sip_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_pre_rule_sip_with_http_info(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（SIP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_sip_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pre_rule_sip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_pre_rule_sip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/sip/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSip',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pre_rule_ssl_offload(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（SSL）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_ssl_offload(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pre_rule_ssl_offload_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pre_rule_ssl_offload_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_pre_rule_ssl_offload_with_http_info(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（SSL）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_ssl_offload_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pre_rule_ssl_offload" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_pre_rule_ssl_offload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pre_rule_ssl_offload_https(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（HTTPS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_ssl_offload_https(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pre_rule_ssl_offload_https_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pre_rule_ssl_offload_https_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_pre_rule_ssl_offload_https_with_http_info(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（HTTPS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_ssl_offload_https_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pre_rule_ssl_offload_https" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_pre_rule_ssl_offload_https`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload-https/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffloadHttps',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pre_rule_tcp_forward(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（TCP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_tcp_forward(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pre_rule_tcp_forward_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pre_rule_tcp_forward_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_pre_rule_tcp_forward_with_http_info(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（TCP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_tcp_forward_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pre_rule_tcp_forward" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_pre_rule_tcp_forward`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-forward/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pre_rule_tcp_proxy(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（TCP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_tcp_proxy(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pre_rule_tcp_proxy_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pre_rule_tcp_proxy_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_pre_rule_tcp_proxy_with_http_info(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（TCP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_tcp_proxy_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pre_rule_tcp_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_pre_rule_tcp_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-proxy/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pre_rule_udp_forward(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（UDP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_udp_forward(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pre_rule_udp_forward_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pre_rule_udp_forward_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_pre_rule_udp_forward_with_http_info(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（UDP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_udp_forward_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pre_rule_udp_forward" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_pre_rule_udp_forward`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-forward/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_pre_rule_udp_proxy(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（UDP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_udp_proxy(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_pre_rule_udp_proxy_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_pre_rule_udp_proxy_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def delete_pre_rule_udp_proxy_with_http_info(self, name, **kwargs):  # noqa: E501
        """delete specific pre-rule  # noqa: E501

        删除指定的前置策略（UDP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_pre_rule_udp_proxy_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_pre_rule_udp_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete_pre_rule_udp_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-proxy/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_pre_rule_dns(self, name, pre_rule_dns_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（DNS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_dns(name, pre_rule_dns_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleDns pre_rule_dns_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_pre_rule_dns_with_http_info(name, pre_rule_dns_property, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_pre_rule_dns_with_http_info(name, pre_rule_dns_property, **kwargs)  # noqa: E501
            return data

    def edit_pre_rule_dns_with_http_info(self, name, pre_rule_dns_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（DNS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_dns_with_http_info(name, pre_rule_dns_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleDns pre_rule_dns_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_dns_property', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_pre_rule_dns" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_pre_rule_dns`")  # noqa: E501
        # verify the required parameter 'pre_rule_dns_property' is set
        if ('pre_rule_dns_property' not in params or
                params['pre_rule_dns_property'] is None):
            raise ValueError("Missing the required parameter `pre_rule_dns_property` when calling `edit_pre_rule_dns`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_dns_property' in params:
            body_params = params['pre_rule_dns_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/dns/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleDns',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_pre_rule_ftp(self, name, pre_rule_ftp_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（FTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_ftp(name, pre_rule_ftp_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleFtp pre_rule_ftp_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_pre_rule_ftp_with_http_info(name, pre_rule_ftp_property, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_pre_rule_ftp_with_http_info(name, pre_rule_ftp_property, **kwargs)  # noqa: E501
            return data

    def edit_pre_rule_ftp_with_http_info(self, name, pre_rule_ftp_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（FTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_ftp_with_http_info(name, pre_rule_ftp_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleFtp pre_rule_ftp_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_ftp_property', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_pre_rule_ftp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_pre_rule_ftp`")  # noqa: E501
        # verify the required parameter 'pre_rule_ftp_property' is set
        if ('pre_rule_ftp_property' not in params or
                params['pre_rule_ftp_property'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ftp_property` when calling `edit_pre_rule_ftp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ftp_property' in params:
            body_params = params['pre_rule_ftp_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ftp/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleFtp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_pre_rule_http(self, name, pre_rule_http_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（HTTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_http(name, pre_rule_http_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleHttp pre_rule_http_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_pre_rule_http_with_http_info(name, pre_rule_http_property, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_pre_rule_http_with_http_info(name, pre_rule_http_property, **kwargs)  # noqa: E501
            return data

    def edit_pre_rule_http_with_http_info(self, name, pre_rule_http_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（HTTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_http_with_http_info(name, pre_rule_http_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleHttp pre_rule_http_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_http_property', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_pre_rule_http" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_pre_rule_http`")  # noqa: E501
        # verify the required parameter 'pre_rule_http_property' is set
        if ('pre_rule_http_property' not in params or
                params['pre_rule_http_property'] is None):
            raise ValueError("Missing the required parameter `pre_rule_http_property` when calling `edit_pre_rule_http`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_http_property' in params:
            body_params = params['pre_rule_http_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/http/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleHttp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_pre_rule_ip(self, name, pre_rule_ip_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的IP三层前置策略（L3）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_ip(name, pre_rule_ip_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleIp pre_rule_ip_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_pre_rule_ip_with_http_info(name, pre_rule_ip_property, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_pre_rule_ip_with_http_info(name, pre_rule_ip_property, **kwargs)  # noqa: E501
            return data

    def edit_pre_rule_ip_with_http_info(self, name, pre_rule_ip_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的IP三层前置策略（L3）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_ip_with_http_info(name, pre_rule_ip_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleIp pre_rule_ip_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_ip_property', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_pre_rule_ip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_pre_rule_ip`")  # noqa: E501
        # verify the required parameter 'pre_rule_ip_property' is set
        if ('pre_rule_ip_property' not in params or
                params['pre_rule_ip_property'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ip_property` when calling `edit_pre_rule_ip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ip_property' in params:
            body_params = params['pre_rule_ip_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ip/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleIp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_pre_rule_radius(self, name, pre_rule_radius_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（RADIUS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_radius(name, pre_rule_radius_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleRadius pre_rule_radius_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_pre_rule_radius_with_http_info(name, pre_rule_radius_property, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_pre_rule_radius_with_http_info(name, pre_rule_radius_property, **kwargs)  # noqa: E501
            return data

    def edit_pre_rule_radius_with_http_info(self, name, pre_rule_radius_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（RADIUS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_radius_with_http_info(name, pre_rule_radius_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleRadius pre_rule_radius_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_radius_property', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_pre_rule_radius" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_pre_rule_radius`")  # noqa: E501
        # verify the required parameter 'pre_rule_radius_property' is set
        if ('pre_rule_radius_property' not in params or
                params['pre_rule_radius_property'] is None):
            raise ValueError("Missing the required parameter `pre_rule_radius_property` when calling `edit_pre_rule_radius`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_radius_property' in params:
            body_params = params['pre_rule_radius_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/radius/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleRadius',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_pre_rule_sip(self, name, pre_rule_sip_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（SIP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_sip(name, pre_rule_sip_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSip pre_rule_sip_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_pre_rule_sip_with_http_info(name, pre_rule_sip_property, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_pre_rule_sip_with_http_info(name, pre_rule_sip_property, **kwargs)  # noqa: E501
            return data

    def edit_pre_rule_sip_with_http_info(self, name, pre_rule_sip_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（SIP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_sip_with_http_info(name, pre_rule_sip_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSip pre_rule_sip_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_sip_property', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_pre_rule_sip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_pre_rule_sip`")  # noqa: E501
        # verify the required parameter 'pre_rule_sip_property' is set
        if ('pre_rule_sip_property' not in params or
                params['pre_rule_sip_property'] is None):
            raise ValueError("Missing the required parameter `pre_rule_sip_property` when calling `edit_pre_rule_sip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_sip_property' in params:
            body_params = params['pre_rule_sip_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/sip/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSip',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_pre_rule_ssl_offload(self, name, pre_rule_ssl_offload_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（SSL）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_ssl_offload(name, pre_rule_ssl_offload_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSslOffload pre_rule_ssl_offload_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_pre_rule_ssl_offload_with_http_info(name, pre_rule_ssl_offload_property, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_pre_rule_ssl_offload_with_http_info(name, pre_rule_ssl_offload_property, **kwargs)  # noqa: E501
            return data

    def edit_pre_rule_ssl_offload_with_http_info(self, name, pre_rule_ssl_offload_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（SSL）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_ssl_offload_with_http_info(name, pre_rule_ssl_offload_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSslOffload pre_rule_ssl_offload_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_ssl_offload_property', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_pre_rule_ssl_offload" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_pre_rule_ssl_offload`")  # noqa: E501
        # verify the required parameter 'pre_rule_ssl_offload_property' is set
        if ('pre_rule_ssl_offload_property' not in params or
                params['pre_rule_ssl_offload_property'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ssl_offload_property` when calling `edit_pre_rule_ssl_offload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ssl_offload_property' in params:
            body_params = params['pre_rule_ssl_offload_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_pre_rule_ssl_offload_https(self, name, pre_rule_ssl_offload_https_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（HTTPS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_ssl_offload_https(name, pre_rule_ssl_offload_https_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSslOffloadHttps pre_rule_ssl_offload_https_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_pre_rule_ssl_offload_https_with_http_info(name, pre_rule_ssl_offload_https_property, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_pre_rule_ssl_offload_https_with_http_info(name, pre_rule_ssl_offload_https_property, **kwargs)  # noqa: E501
            return data

    def edit_pre_rule_ssl_offload_https_with_http_info(self, name, pre_rule_ssl_offload_https_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（HTTPS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_ssl_offload_https_with_http_info(name, pre_rule_ssl_offload_https_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSslOffloadHttps pre_rule_ssl_offload_https_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_ssl_offload_https_property', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_pre_rule_ssl_offload_https" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_pre_rule_ssl_offload_https`")  # noqa: E501
        # verify the required parameter 'pre_rule_ssl_offload_https_property' is set
        if ('pre_rule_ssl_offload_https_property' not in params or
                params['pre_rule_ssl_offload_https_property'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ssl_offload_https_property` when calling `edit_pre_rule_ssl_offload_https`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ssl_offload_https_property' in params:
            body_params = params['pre_rule_ssl_offload_https_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload-https/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffloadHttps',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_pre_rule_tcp_forward(self, name, pre_rule_tcp_forward_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（TCP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_tcp_forward(name, pre_rule_tcp_forward_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleTcpForward pre_rule_tcp_forward_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_pre_rule_tcp_forward_with_http_info(name, pre_rule_tcp_forward_property, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_pre_rule_tcp_forward_with_http_info(name, pre_rule_tcp_forward_property, **kwargs)  # noqa: E501
            return data

    def edit_pre_rule_tcp_forward_with_http_info(self, name, pre_rule_tcp_forward_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（TCP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_tcp_forward_with_http_info(name, pre_rule_tcp_forward_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleTcpForward pre_rule_tcp_forward_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_tcp_forward_property', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_pre_rule_tcp_forward" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_pre_rule_tcp_forward`")  # noqa: E501
        # verify the required parameter 'pre_rule_tcp_forward_property' is set
        if ('pre_rule_tcp_forward_property' not in params or
                params['pre_rule_tcp_forward_property'] is None):
            raise ValueError("Missing the required parameter `pre_rule_tcp_forward_property` when calling `edit_pre_rule_tcp_forward`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_tcp_forward_property' in params:
            body_params = params['pre_rule_tcp_forward_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-forward/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_pre_rule_tcp_proxy(self, name, pre_rule_tcp_proxy_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（TCP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_tcp_proxy(name, pre_rule_tcp_proxy_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleTcpProxy pre_rule_tcp_proxy_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_pre_rule_tcp_proxy_with_http_info(name, pre_rule_tcp_proxy_property, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_pre_rule_tcp_proxy_with_http_info(name, pre_rule_tcp_proxy_property, **kwargs)  # noqa: E501
            return data

    def edit_pre_rule_tcp_proxy_with_http_info(self, name, pre_rule_tcp_proxy_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（TCP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_tcp_proxy_with_http_info(name, pre_rule_tcp_proxy_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleTcpProxy pre_rule_tcp_proxy_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_tcp_proxy_property', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_pre_rule_tcp_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_pre_rule_tcp_proxy`")  # noqa: E501
        # verify the required parameter 'pre_rule_tcp_proxy_property' is set
        if ('pre_rule_tcp_proxy_property' not in params or
                params['pre_rule_tcp_proxy_property'] is None):
            raise ValueError("Missing the required parameter `pre_rule_tcp_proxy_property` when calling `edit_pre_rule_tcp_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_tcp_proxy_property' in params:
            body_params = params['pre_rule_tcp_proxy_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-proxy/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_pre_rule_udp_forward(self, name, pre_rule_udp_forward_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（UDP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_udp_forward(name, pre_rule_udp_forward_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleUdpForward pre_rule_udp_forward_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_pre_rule_udp_forward_with_http_info(name, pre_rule_udp_forward_property, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_pre_rule_udp_forward_with_http_info(name, pre_rule_udp_forward_property, **kwargs)  # noqa: E501
            return data

    def edit_pre_rule_udp_forward_with_http_info(self, name, pre_rule_udp_forward_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（UDP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_udp_forward_with_http_info(name, pre_rule_udp_forward_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleUdpForward pre_rule_udp_forward_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_udp_forward_property', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_pre_rule_udp_forward" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_pre_rule_udp_forward`")  # noqa: E501
        # verify the required parameter 'pre_rule_udp_forward_property' is set
        if ('pre_rule_udp_forward_property' not in params or
                params['pre_rule_udp_forward_property'] is None):
            raise ValueError("Missing the required parameter `pre_rule_udp_forward_property` when calling `edit_pre_rule_udp_forward`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_udp_forward_property' in params:
            body_params = params['pre_rule_udp_forward_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-forward/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_pre_rule_udp_proxy(self, name, pre_rule_udp_proxy_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（UDP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_udp_proxy(name, pre_rule_udp_proxy_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleUdpProxy pre_rule_udp_proxy_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_pre_rule_udp_proxy_with_http_info(name, pre_rule_udp_proxy_property, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_pre_rule_udp_proxy_with_http_info(name, pre_rule_udp_proxy_property, **kwargs)  # noqa: E501
            return data

    def edit_pre_rule_udp_proxy_with_http_info(self, name, pre_rule_udp_proxy_property, **kwargs):  # noqa: E501
        """modify specific pre-rule  # noqa: E501

        修改指定的前置策略（UDP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_pre_rule_udp_proxy_with_http_info(name, pre_rule_udp_proxy_property, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleUdpProxy pre_rule_udp_proxy_property: JSON Config Properties (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_udp_proxy_property', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_pre_rule_udp_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_pre_rule_udp_proxy`")  # noqa: E501
        # verify the required parameter 'pre_rule_udp_proxy_property' is set
        if ('pre_rule_udp_proxy_property' not in params or
                params['pre_rule_udp_proxy_property'] is None):
            raise ValueError("Missing the required parameter `pre_rule_udp_proxy_property` when calling `edit_pre_rule_udp_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_udp_proxy_property' in params:
            body_params = params['pre_rule_udp_proxy_property']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-proxy/{name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/all/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_0(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        获取指定前置策略状态信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_0(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: StatPreRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_0_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_0_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_0_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        获取指定前置策略状态信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_0_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: StatPreRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_0`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/stat/slb/pre-rule/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatPreRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_dns(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（DNS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_dns(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_dns_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_dns_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_dns_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（DNS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_dns_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_dns" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_dns`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/dns/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleDns',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_dns_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（DNS）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_dns_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_dns_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_dns_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_dns_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（DNS）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_dns_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_dns_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/dns/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleDns',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_ftp(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（FTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ftp(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_ftp_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_ftp_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_ftp_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（FTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ftp_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_ftp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_ftp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ftp/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleFtp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_ftp_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（FTP）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ftp_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_ftp_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_ftp_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_ftp_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（FTP）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ftp_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_ftp_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ftp/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleFtp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_http(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_http(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_http_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_http_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_http_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_http_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_http" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_http`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/http/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleHttp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_http_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（HTTP）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_http_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_http_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_http_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_http_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（HTTP）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_http_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_http_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/http/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleHttp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_ip(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的IP三层前置策略（L3）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ip(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_ip_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_ip_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_ip_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的IP三层前置策略（L3）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ip_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_ip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_ip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ip/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleIp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_ip_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的IP三层前置策略（L3）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ip_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_ip_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_ip_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_ip_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的IP三层前置策略（L3）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ip_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_ip_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ip/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleIp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/all/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_list_0(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        获取前置策略状态信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_list_0(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: StatPreRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_list_0_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_list_0_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_list_0_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        获取前置策略状态信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_list_0_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: StatPreRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_list_0" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/stat/slb/pre-rule/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatPreRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_radius(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（RADIUS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_radius(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_radius_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_radius_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_radius_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（RADIUS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_radius_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_radius" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_radius`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/radius/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleRadius',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_radius_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（RADIUS）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_radius_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_radius_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_radius_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_radius_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（RADIUS）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_radius_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_radius_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/radius/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleRadius',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_sip(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（SIP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_sip(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_sip_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_sip_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_sip_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（SIP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_sip_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_sip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_sip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/sip/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSip',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_sip_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（SIP）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_sip_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param str filter: 数据查询条件
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_sip_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_sip_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_sip_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（SIP）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_sip_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param str filter: 数据查询条件
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'filter', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_sip_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'filter' in params:
            query_params.append(('$filter', params['filter']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/sip/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSip',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_ssl_offload(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（SSL）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ssl_offload(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_ssl_offload_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_ssl_offload_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_ssl_offload_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（SSL）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ssl_offload_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_ssl_offload" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_ssl_offload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_ssl_offload_https(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（HTTPS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ssl_offload_https(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_ssl_offload_https_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_ssl_offload_https_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_ssl_offload_https_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（HTTPS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ssl_offload_https_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_ssl_offload_https" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_ssl_offload_https`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload-https/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffloadHttps',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_ssl_offload_https_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（HTTPS）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ssl_offload_https_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_ssl_offload_https_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_ssl_offload_https_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_ssl_offload_https_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（HTTPS）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ssl_offload_https_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_ssl_offload_https_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload-https/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffloadHttps',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_ssl_offload_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（SSL）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ssl_offload_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_ssl_offload_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_ssl_offload_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_ssl_offload_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（SSL）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_ssl_offload_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_ssl_offload_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_tcp_forward(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（TCP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_tcp_forward(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_tcp_forward_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_tcp_forward_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_tcp_forward_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（TCP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_tcp_forward_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_tcp_forward" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_tcp_forward`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-forward/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_tcp_forward_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（TCP）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_tcp_forward_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_tcp_forward_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_tcp_forward_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_tcp_forward_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（TCP）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_tcp_forward_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_tcp_forward_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-forward/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_tcp_proxy(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（TCP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_tcp_proxy(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_tcp_proxy_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_tcp_proxy_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_tcp_proxy_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（TCP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_tcp_proxy_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_tcp_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_tcp_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-proxy/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_tcp_proxy_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（TCP-L7）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_tcp_proxy_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_tcp_proxy_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_tcp_proxy_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_tcp_proxy_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（TCP-L7）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_tcp_proxy_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_tcp_proxy_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-proxy/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_udp_forward(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（UDP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_udp_forward(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_udp_forward_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_udp_forward_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_udp_forward_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（UDP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_udp_forward_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_udp_forward" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_udp_forward`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-forward/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_udp_forward_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（UDP）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_udp_forward_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_udp_forward_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_udp_forward_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_udp_forward_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（UDP）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_udp_forward_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_udp_forward_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-forward/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_udp_proxy(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（UDP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_udp_proxy(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_udp_proxy_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_udp_proxy_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_pre_rule_udp_proxy_with_http_info(self, name, **kwargs):  # noqa: E501
        """get specific pre-rule  # noqa: E501

        查看指定的前置策略（UDP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_udp_proxy_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_udp_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_pre_rule_udp_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-proxy/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pre_rule_udp_proxy_list(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（UDP-L7）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_udp_proxy_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pre_rule_udp_proxy_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_pre_rule_udp_proxy_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_pre_rule_udp_proxy_list_with_http_info(self, **kwargs):  # noqa: E501
        """get all pre-rule  # noqa: E501

        查看当前已有的前置策略（UDP-L7）配置信息  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pre_rule_udp_proxy_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :param int skip: 跳过查询结果前部指定数量的对象
        :param int top: 指定输出列表长度
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['x_token_sangforad', 'all_properties', 'select', 'netns', 'skip', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pre_rule_udp_proxy_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-proxy/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vs_pre_rule(self, virtual_service_name, pre_rule_name, **kwargs):  # noqa: E501
        """get specific pre-rule of virtual service  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vs_pre_rule(virtual_service_name, pre_rule_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str virtual_service_name: config virtual service name (required)
        :param str pre_rule_name: config pre-rule name (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vs_pre_rule_with_http_info(virtual_service_name, pre_rule_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vs_pre_rule_with_http_info(virtual_service_name, pre_rule_name, **kwargs)  # noqa: E501
            return data

    def get_vs_pre_rule_with_http_info(self, virtual_service_name, pre_rule_name, **kwargs):  # noqa: E501
        """get specific pre-rule of virtual service  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vs_pre_rule_with_http_info(virtual_service_name, pre_rule_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str virtual_service_name: config virtual service name (required)
        :param str pre_rule_name: config pre-rule name (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['virtual_service_name', 'pre_rule_name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vs_pre_rule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'virtual_service_name' is set
        if ('virtual_service_name' not in params or
                params['virtual_service_name'] is None):
            raise ValueError("Missing the required parameter `virtual_service_name` when calling `get_vs_pre_rule`")  # noqa: E501
        # verify the required parameter 'pre_rule_name' is set
        if ('pre_rule_name' not in params or
                params['pre_rule_name'] is None):
            raise ValueError("Missing the required parameter `pre_rule_name` when calling `get_vs_pre_rule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'virtual_service_name' in params:
            path_params['virtual_service_name'] = params['virtual_service_name']  # noqa: E501
        if 'pre_rule_name' in params:
            path_params['pre_rule_name'] = params['pre_rule_name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/virtual-service/{virtual_service_name}/pre-rule/{pre_rule_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vs_pre_rule_list(self, virtual_service_name, **kwargs):  # noqa: E501
        """get specific virtual service referenced pre-rule  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vs_pre_rule_list(virtual_service_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str virtual_service_name: config virtual service name (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vs_pre_rule_list_with_http_info(virtual_service_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vs_pre_rule_list_with_http_info(virtual_service_name, **kwargs)  # noqa: E501
            return data

    def get_vs_pre_rule_list_with_http_info(self, virtual_service_name, **kwargs):  # noqa: E501
        """get specific virtual service referenced pre-rule  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vs_pre_rule_list_with_http_info(virtual_service_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str virtual_service_name: config virtual service name (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['virtual_service_name', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vs_pre_rule_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'virtual_service_name' is set
        if ('virtual_service_name' not in params or
                params['virtual_service_name'] is None):
            raise ValueError("Missing the required parameter `virtual_service_name` when calling `get_vs_pre_rule_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'virtual_service_name' in params:
            path_params['virtual_service_name'] = params['virtual_service_name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/virtual-service/{virtual_service_name}/pre-rule/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_pre_rule_dns(self, name, pre_rule_dns_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（DNS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_dns(name, pre_rule_dns_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleDns pre_rule_dns_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replace_pre_rule_dns_with_http_info(name, pre_rule_dns_config, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_pre_rule_dns_with_http_info(name, pre_rule_dns_config, **kwargs)  # noqa: E501
            return data

    def replace_pre_rule_dns_with_http_info(self, name, pre_rule_dns_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（DNS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_dns_with_http_info(name, pre_rule_dns_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleDns pre_rule_dns_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleDns
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_dns_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_pre_rule_dns" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `replace_pre_rule_dns`")  # noqa: E501
        # verify the required parameter 'pre_rule_dns_config' is set
        if ('pre_rule_dns_config' not in params or
                params['pre_rule_dns_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_dns_config` when calling `replace_pre_rule_dns`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_dns_config' in params:
            body_params = params['pre_rule_dns_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/dns/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleDns',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_pre_rule_ftp(self, name, pre_rule_ftp_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（FTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_ftp(name, pre_rule_ftp_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleFtp pre_rule_ftp_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replace_pre_rule_ftp_with_http_info(name, pre_rule_ftp_config, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_pre_rule_ftp_with_http_info(name, pre_rule_ftp_config, **kwargs)  # noqa: E501
            return data

    def replace_pre_rule_ftp_with_http_info(self, name, pre_rule_ftp_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（FTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_ftp_with_http_info(name, pre_rule_ftp_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleFtp pre_rule_ftp_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleFtp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_ftp_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_pre_rule_ftp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `replace_pre_rule_ftp`")  # noqa: E501
        # verify the required parameter 'pre_rule_ftp_config' is set
        if ('pre_rule_ftp_config' not in params or
                params['pre_rule_ftp_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ftp_config` when calling `replace_pre_rule_ftp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ftp_config' in params:
            body_params = params['pre_rule_ftp_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ftp/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleFtp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_pre_rule_http(self, name, pre_rule_http_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（HTTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_http(name, pre_rule_http_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleHttp pre_rule_http_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replace_pre_rule_http_with_http_info(name, pre_rule_http_config, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_pre_rule_http_with_http_info(name, pre_rule_http_config, **kwargs)  # noqa: E501
            return data

    def replace_pre_rule_http_with_http_info(self, name, pre_rule_http_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（HTTP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_http_with_http_info(name, pre_rule_http_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleHttp pre_rule_http_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleHttp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_http_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_pre_rule_http" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `replace_pre_rule_http`")  # noqa: E501
        # verify the required parameter 'pre_rule_http_config' is set
        if ('pre_rule_http_config' not in params or
                params['pre_rule_http_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_http_config` when calling `replace_pre_rule_http`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_http_config' in params:
            body_params = params['pre_rule_http_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/http/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleHttp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_pre_rule_ip(self, name, pre_rule_ip_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的IP三层前置策略（L3）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_ip(name, pre_rule_ip_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleIp pre_rule_ip_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replace_pre_rule_ip_with_http_info(name, pre_rule_ip_config, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_pre_rule_ip_with_http_info(name, pre_rule_ip_config, **kwargs)  # noqa: E501
            return data

    def replace_pre_rule_ip_with_http_info(self, name, pre_rule_ip_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的IP三层前置策略（L3）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_ip_with_http_info(name, pre_rule_ip_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleIp pre_rule_ip_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleIp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_ip_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_pre_rule_ip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `replace_pre_rule_ip`")  # noqa: E501
        # verify the required parameter 'pre_rule_ip_config' is set
        if ('pre_rule_ip_config' not in params or
                params['pre_rule_ip_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ip_config` when calling `replace_pre_rule_ip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ip_config' in params:
            body_params = params['pre_rule_ip_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ip/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleIp',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_pre_rule_radius(self, name, pre_rule_radius_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（RADIUS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_radius(name, pre_rule_radius_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleRadius pre_rule_radius_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replace_pre_rule_radius_with_http_info(name, pre_rule_radius_config, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_pre_rule_radius_with_http_info(name, pre_rule_radius_config, **kwargs)  # noqa: E501
            return data

    def replace_pre_rule_radius_with_http_info(self, name, pre_rule_radius_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（RADIUS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_radius_with_http_info(name, pre_rule_radius_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleRadius pre_rule_radius_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleRadius
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_radius_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_pre_rule_radius" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `replace_pre_rule_radius`")  # noqa: E501
        # verify the required parameter 'pre_rule_radius_config' is set
        if ('pre_rule_radius_config' not in params or
                params['pre_rule_radius_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_radius_config` when calling `replace_pre_rule_radius`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_radius_config' in params:
            body_params = params['pre_rule_radius_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/radius/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleRadius',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_pre_rule_sip(self, name, pre_rule_sip_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（SIP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_sip(name, pre_rule_sip_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSip pre_rule_sip_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replace_pre_rule_sip_with_http_info(name, pre_rule_sip_config, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_pre_rule_sip_with_http_info(name, pre_rule_sip_config, **kwargs)  # noqa: E501
            return data

    def replace_pre_rule_sip_with_http_info(self, name, pre_rule_sip_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（SIP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_sip_with_http_info(name, pre_rule_sip_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSip pre_rule_sip_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSip
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_sip_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_pre_rule_sip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `replace_pre_rule_sip`")  # noqa: E501
        # verify the required parameter 'pre_rule_sip_config' is set
        if ('pre_rule_sip_config' not in params or
                params['pre_rule_sip_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_sip_config` when calling `replace_pre_rule_sip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_sip_config' in params:
            body_params = params['pre_rule_sip_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/sip/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSip',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_pre_rule_ssl_offload(self, name, pre_rule_ssl_offload_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（SSL）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_ssl_offload(name, pre_rule_ssl_offload_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSslOffload pre_rule_ssl_offload_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replace_pre_rule_ssl_offload_with_http_info(name, pre_rule_ssl_offload_config, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_pre_rule_ssl_offload_with_http_info(name, pre_rule_ssl_offload_config, **kwargs)  # noqa: E501
            return data

    def replace_pre_rule_ssl_offload_with_http_info(self, name, pre_rule_ssl_offload_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（SSL）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_ssl_offload_with_http_info(name, pre_rule_ssl_offload_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSslOffload pre_rule_ssl_offload_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffload
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_ssl_offload_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_pre_rule_ssl_offload" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `replace_pre_rule_ssl_offload`")  # noqa: E501
        # verify the required parameter 'pre_rule_ssl_offload_config' is set
        if ('pre_rule_ssl_offload_config' not in params or
                params['pre_rule_ssl_offload_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ssl_offload_config` when calling `replace_pre_rule_ssl_offload`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ssl_offload_config' in params:
            body_params = params['pre_rule_ssl_offload_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffload',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_pre_rule_ssl_offload_https(self, name, pre_rule_ssl_offload_https_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（HTTPS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_ssl_offload_https(name, pre_rule_ssl_offload_https_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSslOffloadHttps pre_rule_ssl_offload_https_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replace_pre_rule_ssl_offload_https_with_http_info(name, pre_rule_ssl_offload_https_config, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_pre_rule_ssl_offload_https_with_http_info(name, pre_rule_ssl_offload_https_config, **kwargs)  # noqa: E501
            return data

    def replace_pre_rule_ssl_offload_https_with_http_info(self, name, pre_rule_ssl_offload_https_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（HTTPS）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_ssl_offload_https_with_http_info(name, pre_rule_ssl_offload_https_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleSslOffloadHttps pre_rule_ssl_offload_https_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleSslOffloadHttps
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_ssl_offload_https_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_pre_rule_ssl_offload_https" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `replace_pre_rule_ssl_offload_https`")  # noqa: E501
        # verify the required parameter 'pre_rule_ssl_offload_https_config' is set
        if ('pre_rule_ssl_offload_https_config' not in params or
                params['pre_rule_ssl_offload_https_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_ssl_offload_https_config` when calling `replace_pre_rule_ssl_offload_https`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_ssl_offload_https_config' in params:
            body_params = params['pre_rule_ssl_offload_https_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/ssl-offload-https/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleSslOffloadHttps',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_pre_rule_tcp_forward(self, name, pre_rule_tcp_forward_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（TCP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_tcp_forward(name, pre_rule_tcp_forward_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleTcpForward pre_rule_tcp_forward_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replace_pre_rule_tcp_forward_with_http_info(name, pre_rule_tcp_forward_config, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_pre_rule_tcp_forward_with_http_info(name, pre_rule_tcp_forward_config, **kwargs)  # noqa: E501
            return data

    def replace_pre_rule_tcp_forward_with_http_info(self, name, pre_rule_tcp_forward_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（TCP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_tcp_forward_with_http_info(name, pre_rule_tcp_forward_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleTcpForward pre_rule_tcp_forward_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_tcp_forward_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_pre_rule_tcp_forward" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `replace_pre_rule_tcp_forward`")  # noqa: E501
        # verify the required parameter 'pre_rule_tcp_forward_config' is set
        if ('pre_rule_tcp_forward_config' not in params or
                params['pre_rule_tcp_forward_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_tcp_forward_config` when calling `replace_pre_rule_tcp_forward`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_tcp_forward_config' in params:
            body_params = params['pre_rule_tcp_forward_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-forward/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_pre_rule_tcp_proxy(self, name, pre_rule_tcp_proxy_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（TCP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_tcp_proxy(name, pre_rule_tcp_proxy_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleTcpProxy pre_rule_tcp_proxy_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replace_pre_rule_tcp_proxy_with_http_info(name, pre_rule_tcp_proxy_config, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_pre_rule_tcp_proxy_with_http_info(name, pre_rule_tcp_proxy_config, **kwargs)  # noqa: E501
            return data

    def replace_pre_rule_tcp_proxy_with_http_info(self, name, pre_rule_tcp_proxy_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（TCP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_tcp_proxy_with_http_info(name, pre_rule_tcp_proxy_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleTcpProxy pre_rule_tcp_proxy_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleTcpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_tcp_proxy_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_pre_rule_tcp_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `replace_pre_rule_tcp_proxy`")  # noqa: E501
        # verify the required parameter 'pre_rule_tcp_proxy_config' is set
        if ('pre_rule_tcp_proxy_config' not in params or
                params['pre_rule_tcp_proxy_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_tcp_proxy_config` when calling `replace_pre_rule_tcp_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_tcp_proxy_config' in params:
            body_params = params['pre_rule_tcp_proxy_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/tcp-proxy/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleTcpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_pre_rule_udp_forward(self, name, pre_rule_udp_forward_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（UDP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_udp_forward(name, pre_rule_udp_forward_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleUdpForward pre_rule_udp_forward_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replace_pre_rule_udp_forward_with_http_info(name, pre_rule_udp_forward_config, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_pre_rule_udp_forward_with_http_info(name, pre_rule_udp_forward_config, **kwargs)  # noqa: E501
            return data

    def replace_pre_rule_udp_forward_with_http_info(self, name, pre_rule_udp_forward_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（UDP）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_udp_forward_with_http_info(name, pre_rule_udp_forward_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleUdpForward pre_rule_udp_forward_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpForward
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_udp_forward_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_pre_rule_udp_forward" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `replace_pre_rule_udp_forward`")  # noqa: E501
        # verify the required parameter 'pre_rule_udp_forward_config' is set
        if ('pre_rule_udp_forward_config' not in params or
                params['pre_rule_udp_forward_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_udp_forward_config` when calling `replace_pre_rule_udp_forward`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_udp_forward_config' in params:
            body_params = params['pre_rule_udp_forward_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-forward/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpForward',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replace_pre_rule_udp_proxy(self, name, pre_rule_udp_proxy_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（UDP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_udp_proxy(name, pre_rule_udp_proxy_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleUdpProxy pre_rule_udp_proxy_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replace_pre_rule_udp_proxy_with_http_info(name, pre_rule_udp_proxy_config, **kwargs)  # noqa: E501
        else:
            (data) = self.replace_pre_rule_udp_proxy_with_http_info(name, pre_rule_udp_proxy_config, **kwargs)  # noqa: E501
            return data

    def replace_pre_rule_udp_proxy_with_http_info(self, name, pre_rule_udp_proxy_config, **kwargs):  # noqa: E501
        """replace specific pre-rule  # noqa: E501

        修改指定的前置策略（UDP-L7）配置  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replace_pre_rule_udp_proxy_with_http_info(name, pre_rule_udp_proxy_config, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: 配置名称 (required)
        :param ConfigPreRuleUdpProxy pre_rule_udp_proxy_config: JSON Config Object (required)
        :param str x_token_sangforad: AD会话令牌
        :param bool all_properties: 输出对象的全部字段信息，未设置属性则输出默认值。
        :param str select: 定义查询结果集的数据项
        :param str netns: mynetns, netns-default, project-common
        :return: ConfigPreRuleUdpProxy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'pre_rule_udp_proxy_config', 'x_token_sangforad', 'all_properties', 'select', 'netns']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_pre_rule_udp_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `replace_pre_rule_udp_proxy`")  # noqa: E501
        # verify the required parameter 'pre_rule_udp_proxy_config' is set
        if ('pre_rule_udp_proxy_config' not in params or
                params['pre_rule_udp_proxy_config'] is None):
            raise ValueError("Missing the required parameter `pre_rule_udp_proxy_config` when calling `replace_pre_rule_udp_proxy`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'all_properties' in params:
            query_params.append(('all_properties', params['all_properties']))  # noqa: E501
        if 'select' in params:
            query_params.append(('$select', params['select']))  # noqa: E501
        if 'netns' in params:
            query_params.append(('netns', params['netns']))  # noqa: E501

        header_params = {}
        if 'x_token_sangforad' in params:
            header_params['x-token-sangforad'] = params['x_token_sangforad']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'pre_rule_udp_proxy_config' in params:
            body_params = params['pre_rule_udp_proxy_config']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic_auth']  # noqa: E501

        return self.api_client.call_api(
            '/api/ad/v3/slb/pre-rule/udp-proxy/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigPreRuleUdpProxy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
