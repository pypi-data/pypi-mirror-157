# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['compic10', 'compic10.vm']

package_data = \
{'': ['*']}

install_requires = \
['PyYAML>=6.0,<7.0', 'clipboard>=0.0.4,<0.0.5']

setup_kwargs = {
    'name': 'compic10',
    'version': '1.1.0',
    'description': 'A fully fledged compiler and emulator for the IC10-MIPS processor of the game Stationeers.',
    'long_description': '# compIC10\ncompIC10 is an compiler for the "IC10" from the game Stationeers. It supports common programming language features like\nloops, if-statements, functions, procedures (functions without return value), variables and expressions.\nCurrently there may still be bugs.\n\n## How to install\nJust install Python3 version 3.8.2 or later (earlier versions probably work too) and afterwards install clipboard with pip: \n\n    pip3 install clipboard\n## Programming Language\n### Basics\nAll statements are limited to a single line, blank lines are allowed.\nEvery line can only contain one statement which means every statement ends with and linebreak.\nWhen referring to names meant are strings starting with an \\\'\\_\\\' or letter followed by zero or more \\\'\\_\\\', letters or numbers.\nNames can not be keywords.\nThere are no types since every operation in stationeers results in a number.\nEverything is case sensitive. Multiple Spaces or tabs are beeing ignored by the compiler meaning indention is possible but not enforced.\n\nAfter compilation success compiler starts Post Process Optimizations for remove redundant and garbage code from result code.\n\n### Compilation Errors\nWhen there is an error in the source code the compiler will notice you and tell you at which line the error is.\nIf the compiler yields some python-exception than there may be a bug in the programm or in the source code.\n### Post Processor Errors\nWhen you get that error I recommend use --no_post_processing_optimization command line key for disable Post Process Optimizations. In normal case that error should not be appearing.\n### Runtime Errors\nWhen the program ends up in an unrecoverable state it sets the state of the IC10 housing to an error code and turns the IC10 off.\nCurrently there is only the error-state -1 which means an function ended without an `return` statement.\nUnfortunately AIMEe doesn\'t support a state so he will just turn off.\n## Compiler\n**Basic usage:**\n\n    python3 compIC10 [source_file]\nCompiles the source code in file source_file. Doesn\'t save the result anywhere use following parameters in order to get the result (without parameters version still useful to verify code).\n**Parameters:**\n\n    -o [file], --out_file [file]\nSafes generated code in [file].\n\n    -p, --print_output\nPrints code to the stdout.\n\n    -c, --copy\nCopys resulting code to clipboard.\n\n    -a, --annotate\nCreates comments in the generated code in order to easily associate source-code with asm-code.\n\n    -s, --offset_varstack [offset]\nSets the location reserved for variables in the stack.\n\n    -l, --length_varstack [length]\nSets the length of the reserved section in stack for variables. \noffset+length must be less then 512.\n\n    --silent\nSilent any console output, except code output with -p key\n\n    --no_post_processing_optimization\nDisable Post Processor Optimizations.\nPPO can be buggy now, if asm code not work correctly try to use that key for complete disable PPO\n\n    \n\n## Statements\n### Comments\nComments start with an `#`. Everything after this symbol on the current line will be ignored by the compiler.\nThe following code is a comment with comment message [comment]:\n\n    # [comment]\nComments on an seperate line will be placed in the resulting asm-code when using `--annotate`.\n### main\nEvery program starts in the main block given by:\n\n    main\n    [main code]\n    end\n`[main code]` is the source code of main.\n### Number literals\nNumber literals can be the following:\nInteger Numbers:\n\n    1\n\nFloat numbers:\n\n    1.1\nShortcuts like .1 or 1. are possible.\nExponential number literals:\n\n    1.1e5\n    1.1E5\n    1.1e-5\n    1.1E-5\n    1.1e+5\n    1.1E+5\n\nSince Stationeers doesn\'t support scientfic notation floating point numbers in this compiler will be limited to at most 16 digits behind the comma.\nBinary numbers:\n\n    0b0101\nHexadecimal numbers:\n\n    0xFF\nBooleans:\n\n    true\n    false\nTrue is represented as an 1 and false as an 0.\nNote that all number literals are positive an additional minus (-) before that is an expression of unary - and the number literal.\n### Variables\nThe following code generates a variable with name `[name]` and (1) initial value 0 or (2) initial value beeing the \nresult of the expression `[expression]`:\n\n    var [name]\n    var [name] = [expression]\nVariables can be used in the current block (namespace) and inner blocks.\nGlobal variables are possible too. Those unfortunately require an bigger overhead.\n### Constants\nThe following code generates a constant with name `[name]` and value `[value]`.\n\n    const [name] = [value]\nLike variables, constants will be available in the current block and all inner blocks.\nThe value must be known at compile time (no expressions allowed only number literals) an optional +/- before the number is allowed.\n### Devices \nThe following code assignes device number `[dev]` on the IC10 to the name `[name]`:\n\n    dev [name] = [dev]\nThe \'d\' like in `d0` must be omitted here.\nValues of device `[name]` propertys `[property]` can be modified and written to by:\n\n    [name].[property]\nThis statement can be used like an variable.\nIf the device has slots, a certain slot `[slot]` get accessed by:\n\n    [name][ [slot] ].[property]\n\nIn order to access reagents use:\n\n    [name].[reagentmode].[property]\n`[reagent]` has to be one of: `Contents`, `Required`, `Recipe`.\n\nThe special device `db` can always be accessed with the keyword `self`.\n`[name]` can also be an variable or constant for dynamic device access.\n`[name]` in an expression refers to the pin on the housing set by the device declaration.\nThe special device property `DeviceIsSet` can be readed for check port is configured on socket\n### Batch Devices \nThe following code associates all devices on the network with itemhash `[hash]` on the IC10 with the name `[name]`:\n\n    bdev [name] = [hash]\nItemhashes can be found here: https://stationeers-wiki.com/ItemHash\nValues of batch device `[name]` propertys `[property]` can be read with:\n\n    [name].[property].[batchmode]\n`[batchmode]` is the function used to evaluate all the numbers can be one of: `Average`, `Sum`, `Minimum`, `Maximum`.\nThe property `[property]` of all devices on the network associated with `[name]` can be assigned with the result of an expression `[expression]` by:\n\n    [name].[property] = [expression]\n\n`[name]` in an expression refers to the hash set by the batch device declaration.\n### Functions \nA function with name `[name]` can be defined by the following code:\n\n    func [name]([parameters...])\n    [function body]\n    end\n`[function body]` is the source code of the function.\nThe functions has parameters `[parameters...]` which is a comma seperated collection of names. Default values are supported like `param=1`, `param=-1` or `param=+1` \nafter an parameter with default value can\'t follow one without. All default values must be known at compile time.\nAll functions must end with an `return` statement that has a return value.\nAt the end of the function body is an `end` statement.\nFunctions have their own namespace.\nIf an function ends without and return statement the state of the IC10-housing changes to -1 and it shuts down.\nRecursion is supported.\n### Procedures\nA procedure with name `[name]` can be defined by the following code:\n\n    proc [name]([parameters...])\n    [procedure body]\n    end\n`[procedure body]` is the source code of the procedure.\nThe procedure has parameters `[parameters...]` which is a comma seperated collection of names. Default values are supported like `param=1`, `param=-1` or `param=+1`\nafter an parameter with default value can\'t follow one without. All default values must be known at compile time.\nAt the end of the procedure body is an `end`.\nProcedures don\'t have to end with an `return` statement.\nProcedures have their own namespace.\nRecursion is supported.\n### return\nFunctions can be returned from everywhere with an return statement like:\n\n    return [expression]\nThe return value is the result of expression `[expression]`.\nSame goes for procedures but without an return value:\n\n    return\n`return` is only allowed within functions or procedures.\n### Expressions\nExpression are mathematical statements where operators are connected with variables, number literals, devices, batch devices, \nsubexpressions within braces () or functions.\nExpressions are always evaluated from left to right for operators with equal priorities. \nAn exception to that are assignment operations. Those are evaluated from right to left when grouped like `a=b=c`.\nSupported operators from higher to lower priority (grouped have equal priority):\n\n    -- [operand]  # decrement: [operand] = [operand] - 1\n    ++ [operand]  # increment: [operand] = [operand] + 1\n\n    + [operand]  # * 1 (do nothing)\n    - [operand]  # * -1\n\n    # Currently not implemented but recognized:\n    ~ [operand]  # bitwise negate\n    \n    [operand1] * [operand2]  # multiply\n    [operand1] / [operand2]  # divide\n    [operand1] % [operand2]  # modulus\n\n    [operand1] + [operand2]  # add\n    [operand1] - [operand2]  # subtract\n    \n    # Currently not implemented but recognized:\n    [operand1] << [operand2]  # shift left\n    # Currently not implemented but recognized:\n    [operand1] >> [operand2]  # shift right\n    \n    # Currently not implemented but recognized:\n    [operand1] & [operand2]  # bitwise and \n    \n    # Currently not implemented but recognized:\n    [operand1] ^ [operand2]  # bitwise xor\n    \n    # Currently not implemented but recognized:\n    [operand1] | [operand2]  # bitwise or\n\n    [operand1] == [operand2]  # equal\n    [operand1] != [operand2]  # not equal\n    [operand1] < [operand2]  # less\n    [operand1] <= [operand2]  # less equal\n    [operand1] > [operand2]  # greater\n    [operand1] >= [operand2]  # greater equal\n\n    ! [operand]     # logical not\n    \n    [operand1] && [operand2]  # logical and\n    \n    [operand1] || [operand2]  # logical or\n    \n    [operand1] = [operand2]  # assignment\n    [operand1] += [operand2]  # assign and add:  [operand1] = [operand1] + [operand2]\n    [operand1] -= [operand2]  # assign and subtract:  [operand1] = [operand1] - [operand2]\n    [operand1] *= [operand2]  # assign and multiply:  [operand1] = [operand1] * [operand2]\n    [operand1] /= [operand2]  # assign and divide:  [operand1] = [operand1] / [operand2]\n    [operand1] %= [operand2]  # assign and calculate modulus:  [operand1] = [operand1] % [operand2]\n    [operand1] &&= [operand2]  # assign and and:  [operand1] = [operand1] && [operand2]\n    [operand1] ||= [operand2]  # assign and or:  [operand1] = [operand1] || [operand2]\n### if, elif, else\nIf Statements are done the following way:\n\n    if([expression])\n    [if body]\n    elif([expression])\n    [elif body]\n    else\n    [else body]\n    end\nThe first body with an true (nonzero) expression will be executed or if none is true the `else` body will be executed.\nEvery body has its own namespace. Everything except the `if([expression])` and `end` is optional. There can also be more than one elif.\n### while\nWhile loops are done like that:\n\n    while([expression])\n    [while body]\n    end\nThe body will be executed until its exited by `break` or expression `[expression]` is not true anymore.\nEvery iteration can be cut short with `continue`.\n### for\nFor loops are generated the following way:\n\n    for([expression or variable definition], [cond_expression], [iter_expression])\n    [for body]\n    end\n\nFor loops until expression cond_expression is false or it is exited by `break`.\nBefore the loop an expression is executed or a variable in the embedding scope is definded by [expression or variable definition].\nEvery iteration can be cut short with `continue`.\n### continue, break\n\n    continue\n    break\n`break` exits a loop immeditly and `continue` skips the current iteration.\nBoth are only allowed within loops.\n### Inline assembler\nIt is possible to execute IC10-MIPS assembler code [asm code] within the source code through:\n\n    asm [register list and associated variables]\n    [asm code]\n    end\n\nRegister list and associated variables refers to an comma seperated list consisting out of elements representing registers like `$r0`-`$r13` \nand optional associations with variables by writing `$r0-13=[variable]` where variable refers to the identifier of the variable. All modifications to that register will be saved in the variable.\nasm code must start with an `@` like `@move $r0 $r1`.\nIn asm code registers can be used like usual. However the shouldn\'t be since that may break the program they should be addressed with `$r0` - `$r13` so compiler assigned registers will be used that are also safe to use (references to that in comments within inline asm will be replaced to the corresponding compiler-assigned registers as well).\nA maximum of 14 registers can be used like that since `sp`, `ra`, `r14` and `r15` are used by the compiler. `ra`, `r14` and `r15` are however generally save to use within an inline assembler. `sp` must refer to the same value at the end.\nThe registers will in general not be associated with the corresponding registers in IC10 assembler source code, \nsince they could be reserved for variables.\nIt should not be possible to break an program with inline assembler since all used registers get safed before the execution.\nThis is not the case for jump tags. Use of jump tags should be limited to the inline-asm block this however will not be enforced.\n\nIt is possible but not recommended to use asm code outside of an asm statement. Everything after `@` will be placed in the source code without modification (including comments).\n## Examples\n### IC10 giving sphere coordinates for an vector\n\n    dev posx=0\n    dev posy=1\n    dev posz=2\n    dev output_dist=3\n    dev output_phi=4\n    dev output_theta=5\n\n    func atan2(x,y)\n        const pi = 3.14159\n        if(x>0)\n            return atan(y/x)\n        elif(y>0)\n            return pi/2 - atan(x/y)\n        elif(y<0)\n            return -pi/2 - atan(x/y)\n        elif(x<0)\n            return atan(y/x) + pi\n        else\n            return 0\n        end\n        # return is needed here unfortunatly\n        return 0\n    end\n\n    main\n        while(true)\n            # length of vector\n            output_dist.Value = sqrt(posx.Value*posx.Value + posy.Value*posy.Value + posz.Value*posz.Value)\n            # Sphere coordinates\n            output_phi.Value = atan2(posx.Value, posy.Value)\n            output_theta.Value = asin(posz.Value / output_dist.Value)\n            yield()\n        end\n    end\n\n\n### Fibonacci number generator\n    main\n        var l=1\n        var ll=1\n        for(var i=0, i<50, ++i)\n            self.Setting = l+ll\n            ll=l\n            l=self.Setting\n            yield()\n        end\n    end\n\n### Recursive Fibonacci number generator\n\n    func fibonacci(start)\n        if(start <= 2)\n            return 1\n        else\n            return fibonacci(start-2)+fibonacci(start-1)\n        end\n    end\n\n    main\n        self.Setting = fibonacci(9)\n    end\n',
    'author': 'Florian Ullmann',
    'author_email': 'florian.ullmann@protonmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://gitlab.com/smpkdev/compic10',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
