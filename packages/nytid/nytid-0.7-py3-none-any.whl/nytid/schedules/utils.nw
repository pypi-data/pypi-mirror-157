\chapter{Utilities}

In this chapter we cover various utilities.
The outline of the module is as follows:
<<utils.py>>=
import arrow
import csv
import datetime
import nytid.schedules
import re
import requests

<<constants>>
<<functions>>

def main():
  <<usage examples>>

if __name__ == "__main__":
    main()
@


\section{Generate sign up sheet for TAs}

We want to generate a sign-up sheet that TAs can use to sign up for teaching 
sessions, \eg lab or tutorial sessions.
It takes the course title (used for file name) and a URL to TimeEdit for the 
course schedule.
It outputs a CSV that can be imported to Google Sheets that the TAs can fill.
<<functions>>=
def needed_TAs(event):
  """
  Takes an event and returns the number of TAs needed
  """
  <<compute the number of needed TAs>>
  
def generate_signup_sheet(course, url, needed_TAs=needed_TAs):
  """
  Input:
  - course is a string containing the file name used for output.
  - url is the URL to the ICS-formatted calendar.
  - needed_TAs is a function computing the number of needed TAs based on the 
    event. The default is the needed_TAs function in this module.

  Output:
  Returns nothing. Writes output to {course}.csv.
  """
  with open(f"{course}.csv", "w") as out:
    csvout = csv.writer(out)
    calendar = nytid.schedules.read_calendar(url)

    max_num_TAs = 0
    rows = []

    <<generate rows of sign-up sheet>>

    csvout.writerow(SIGNUP_SHEET_HEADER +
      [f"TA username" for n in range(max_num_TAs)] +
        ["..."])

    csvout.writerows(rows)
@

The headers that we want are the following.
<<constants>>=
SIGNUP_SHEET_HEADER = [
  "Event", "Start", "End", "#Rooms",
  "#Needed TAs"
]
@

To generate the rows of the sheet, we simply go through the calendar in 
chronological order.
We only want the TAs to sign up for tutorials (övningar) and labs (laboration).
<<generate rows of sign-up sheet>>=
for event in calendar.timeline:
  if "Övning" in event.name or \
      "laboration" in event.name or "Laboration" in event.name:
    num_TAs = needed_TAs(event)
    if num_TAs > max_num_TAs:
      max_num_TAs = num_TAs

    rows.append([
      event.name,
      event.begin.to("local").format("YYYY-MM-DD HH:mm"),
      event.end.to("local").format("YYYY-MM-DD HH:mm"),
      len(event.location.split(",")),
      num_TAs
    ])
@

<<usage examples>>=
COURSES = {
  "DD1310": 
  "https://cloud.timeedit.net/kth/web/public01/ri.ics?sid=7&p=0.w%2C12.n&objects=453080.10&e=220609&enol=t&ku=29&k=1B9F3AD696BCA5C434C68950EFD376DD",
  "DD1317": 
  "https://cloud.timeedit.net/kth/web/public01/ri.ics?sid=7&p=0.w%2C12.n&objects=455995.10&e=220609&enol=t&ku=29&k=BA4400E3C003685549BC65AD9EAD3DC58E"
}

for course, url in COURSES.items():
  generate_signup_sheet(course, url)
@


\section{Computing the number of necessary TAs}

We need to compute the number of TAs that we need for various sessions.
We compute this number from the parameter [[event]], which is an 
[[ics.event.Event]] object from the schedule.
The base algorithm counts on one TA per group.
If there are no groups, we use one TA per room.
<<compute the number of needed TAs>>=
num_groups = event.description.split().count("grupp")
if num_groups == 0:
  num_groups = event.description.split().count("group")

num_rooms = len(event.location.split(","))

num_TAs = max(num_rooms, num_groups)

if "laboration" in event.name or "Laboration" in event.name:
  num_TAs = round(num_TAs * 1.5)

return num_TAs
@


\section{Reading the sign-up sheet}

We want to read the sign-up sheet to later parse it to extract interesting 
data.
We provide two ways:
\begin{itemize}
\item read from a file.
\item read from a URL.
\end{itemize}
In both cases we want to return the rows of the CSV.

\subsection{Reading from a file}

We simply read the rows from the file.
<<functions>>=
def read_signup_sheet_from_file(filename):
  """
  Input: filename is a string containing the file name of the CSV file of the 
  sign-up sheet.

  Output: All the rows of the CSV as a Python list.
  """
  with open(filename, "r") as f:
    csvfile = csv.reader(f)
    return list(csvfile)[1:]
@

\subsection{Reading from a URL}

We simply download the CSV file and read the rows from the file.
<<functions>>=
def read_signup_sheet_from_url(url):
  """
  Input: url is a string containing the URL of the CSV file of the sign-up 
  sheet.

  Output: All the rows of the CSV as a Python list.
  """
  response = requests.get(url)
  if response.status_code != 200:
    raise ValueError(response.text)

  response.encoding = response.apparent_encoding
  csvdata = response.text.splitlines()
  return list(csv.reader(csvdata))[1:]
@

We also provide a function that takes the sharing URL of a publicly visible 
sheet on Google Sheets and changes it into a URL that exports the sheet to CSV.
<<functions>>=
def google_sheet_to_csv_url(share_url):
  """
  Input: The share URL of a Google Sheets sheet.

  Output: A URL that downloads (exports) the sheet in CSV format.
  """
  match = re.search("/edit.*$", share_url)
  if not match:
    raise ValueError(f"{share_url} doesn't seem like a Google Sheets URL.")

  url = share_url[:match.start()]
  return url + "/export?format=csv"
@


\section{Extracting data from sign-up sheet}

We would also like to parse the sign-up sheet.
Considering the design, we can read out many things.
We are interested in the following:
\begin{itemize}
\item Which TAs are signed up for a particular session? (To organize teaching 
better, \eg automatically generate presentation events in Canvas' calendar for 
the students.)
\item How many hours are spent on TAs on a course? (To keep budget.)
\item How many hours a particular TA spent during a particular period? (To 
generate timesheets.)
\end{itemize}

\subsection{Which TAs signed up for a particular event?}

For this, we just need to take the event (a row of CSV) as input, then cut only 
the list of TAs.
<<functions>>=
def get_TAs_from_csv(csv_row):
  """
  Input: takes a CSV data row as from a csv.reader.

  Output: returns the list of signed TAs.
  """
  return csv_row[len(SIGNUP_SHEET_HEADER):]
@

\subsection{How many hours are spent on the course?}

For this, we just want to go through all the events and multiply the time for 
the event with the number of TAs.
We also multiply by the standard preparation time that the TAs are paid.
\label{HoursPerTA}
<<functions>>=
def hours_per_TA(csv_rows):
  """
  Input: Rows of CSV data as from csv.reader.

  Output: a dictionary mapping a TA to the number of hours they signed up for 
  in the sign-up sheet, {TA: hours}. The hours as datetime.timedelta objects.
  """
  TA_hours = {}

  start_index = SIGNUP_SHEET_HEADER.index("Start")
  end_index = SIGNUP_SHEET_HEADER.index("End")
  event_index = SIGNUP_SHEET_HEADER.index("Event")

  for row in csv_rows:
    time = (arrow.get(row[end_index], "YYYY-MM-DD HH:mm") - \
      arrow.get(row[start_index], "YYYY-MM-DD HH:mm"))

    time = round_time(time)
    time = add_prep_time(time, row[event_index])

    for assistant in get_TAs_from_csv(row):
      if assistant in TA_hours:
        TA_hours[assistant] += time
      else:
        TA_hours[assistant] = time

  return TA_hours
@

Now, from this data we can easily compute the total number of hours.
<<functions>>=
def total_hours(csv_rows):
  """
  Input: Rows of CSV data as from csv.reader.

  Output: Total number of hours spent on the course, as a datetime.timedelta 
  object.
  """
  total = datetime.timedelta(0)
  TA_hours = hours_per_TA(csv_rows)
  TA_hours[""] = datetime.timedelta(0)

  for _, hours in TA_hours.items():
    total += hours

  return total
@

We also want to compute the maximum number of hours.
<<functions>>=
def max_hours(csv_rows):
  """
  Input: takes the rows of CSV as output from csv.reader.

  Output: returns the maximum number of hours (using maximum TAs needed), as a 
  detetime.timedelta object.
  """
  start_index = SIGNUP_SHEET_HEADER.index("Start")
  end_index = SIGNUP_SHEET_HEADER.index("End")
  event_index = SIGNUP_SHEET_HEADER.index("Event")
  needed_TAs_index = SIGNUP_SHEET_HEADER.index("#Needed TAs")

  max_hours = datetime.timedelta()

  for row in csv_rows:
    time = (arrow.get(row[end_index], "YYYY-MM-DD HH:mm") - \
      arrow.get(row[start_index], "YYYY-MM-DD HH:mm"))

    time = round_time(time)
    time = add_prep_time(time, row[event_index])

    max_num_TAs = int(row[needed_TAs_index])

    max_hours += time * max_num_TAs

  return max_hours
@


\subsection{Rounding time and adding prep time correctly}

KTH uses some rounding procedure for worked time.
We should round to half hours.
<<functions>>=
def round_time(time):
  """
  Input: a datetime.timedelta object time.

  Output: the time object rounded according to KTH rules.
  """
  HOUR = 60*60
  QUARTER = 15*60

  total_seconds = time.total_seconds()
  full_hours = (total_seconds // HOUR) * HOUR
  part_hour = total_seconds % HOUR

  if part_hour >= 3*QUARTER:
    return datetime.timedelta(seconds=full_hours+HOUR)
  elif part_hour > 2*QUARTER:
    return datetime.timedelta(seconds=full_hours+2*QUARTER)
  elif part_hour >= QUARTER:
    return datetime.timedelta(seconds=full_hours+2*QUARTER)

  return datetime.timedelta(seconds=full_hours)
@

We also should add some fixed preparation time that depends on the type of 
event.
Lab session time should increase by a third, tutorial session time should 
double.
<<functions>>=
def add_prep_time(time, event_type):
  """
  Input: a datetime.timedelta object time,
    a string containing the title of the event.

  Output: the time object rounded according to KTH rules.
  """
  if "laboration" in event_type or "Laboration" in event_type:
    time *= 1.33
  elif "Övning" in event_type:
    time *= 2

  return time
@


\subsection{Compute amanuensis employment data\protect\footnote{%
  Based on the idea from Mazen Mardini to automatically compute the 
  percentage.
  However, we expand on the idea a bit here.
}}

We want to compute the data needed to start an amanuensis employment.
We want to compute the following:
\begin{itemize}
\item the total number of hours for the employment period,
\item the employment period and percentage for the employment.
\end{itemize}

The total number of hours for the TA is already solved above 
(\cref{HoursPerTA}).
The key is to compute the employment period and the percentage.
We want to compute the period and percentage most beneficial for the TA.
We will take the following appraoch:
\begin{enumerate}
\item Check which slots are signed up for.
\item Round to the month.
  If the first slot is at 29th August, we start the position at 1st August.
\item Compute the percentage.
  If the percentage is too low, \ie lower than 10 percent, we shrink the period 
  to the actual first-slot date.
\end{enumerate}
This algorithm gives the following benefit.
The students can have a maximum employment of 50 percent.
If we stretch it, the students can do more hours in total during the period.
If the percentage gets too low, we can use the exact dates to get the 
percentage closer to the minimum 10 percent.
However, if the period is shorter than a month (25 days), we don't offer an 
amanuensis contract.
The rationale for this is that we only trade one time report for a signing the 
amanuensis contract (which is more work), so it's a more temporary position 
when it's that short period of time.

This gives us the following function:
<<functions>>=
def compute_amanuensis_data(csv_rows, low_percentage=0.1, min_days=25):
  """
  Input:
    - csv_rows, the CSV rows as output from csv.reader.
    - low_percentage, the lowest acceptable percentage of an amanuensis 
      contract.
    - min_days is the minimum number of days we accept for an amanuensis 
      contract.

  Output: a dictionary {TA: (start, end, hours)} mapping the TA username to a 
  tuple (start, end, hours) with the start and end time and the total number of 
  hours.
  """
  start_index = SIGNUP_SHEET_HEADER.index("Start")
  end_index = SIGNUP_SHEET_HEADER.index("End")
  event_index = SIGNUP_SHEET_HEADER.index("Event")
  needed_TAs_index = SIGNUP_SHEET_HEADER.index("#Needed TAs")

  ta_hours = hours_per_TA(csv_rows)
  ta_data = {}

  <<compute the earliest and latest dates for each TA>>

  return ta_data
@

We start by finding all start and end dates for every TA.
<<compute the earliest and latest dates for each TA>>=
for ta in ta_hours.keys():
  earliest_date = arrow.get(csv_rows[0][start_index], "YYYY-MM-DD")
  latest_date = arrow.get(csv_rows[0][end_index], "YYYY-MM-DD")

  for row in csv_rows:
    start_date = arrow.get(row[start_index], "YYYY-MM-DD")
    end_date = arrow.get(row[end_index], "YYYY-MM-DD")

    if start_date < earliest_date:
      earliest_date = start_date
    if end_date > latest_date:
      latest_date = end_date

  hours = ta_hours[ta].total_seconds()/60/60

  <<expand earliest and latest dates if beneficial>>

  if  latest_date - earliest_date < datetime.timedelta(days=min_days):
    continue

  ta_data[ta] = (earliest_date, latest_date, hours)
@

Now we want to try to expand the start and end dates to the start and end of 
the month, respectively.
If we can't get above the [[low_percentage]] threshold, we continue to the next 
TA.
<<expand earliest and latest dates if beneficial>>=
earliest_month = arrow.get(
  f"{earliest_date.year}-{earliest_date.month:02d}-01",
  "YYYY-MM-DD")
latest_month = arrow.get(
  f"{latest_date.year}-{latest_date.month:02d}-01",
  "YYYY-MM-DD").shift(months=1, seconds=-1)

if compute_percentage(earliest_month, latest_month, hours) >= low_percentage:
  earliest_date = earliest_month
  latest_date = latest_month
elif compute_percentage(earliest_date, latest_month, hours) >= low_percentage:
  latest_date = latest_month
else:
  continue
@

The [[compute_percentage]] function simply computes the average working time.
<<functions>>=
def compute_percentage(start, end, hours):
  """
  Input: start and end as arrow.arrow.Arrow or datetime.date objects,
    hours as a float.

  Output: a float in the interval [0, 1], which is the percentage of full time.
  """
  days = (end - start).total_seconds()/60/60/24
  full_time = 40 * days / 7
  return hours / full_time
@
